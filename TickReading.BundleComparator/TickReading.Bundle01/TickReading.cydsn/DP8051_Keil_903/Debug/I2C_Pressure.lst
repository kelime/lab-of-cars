C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE I2C_PRESSURE
OBJECT MODULE PLACED IN .\DP8051_Keil_903\Debug\I2C_Pressure.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\2.1\PSoC Creator\import\keil\pk51\9.03\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\I2C_Pressure.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051_Keil_903\Debug\I2C_Pressure.lst) CD DB 
                    -NOIP OT(2,SIZE) INCDIR(Generated_Source\PSoC3) OJ(.\DP8051_Keil_903\Debug\I2C_Pressure.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: I2C_Pressure.c
   3          * Version 3.10
   4          *
   5          * Description:
   6          *  This file provides the source code of APIs for the I2C component.
   7          *  Actual protocol and operation code resides in the interrupt service routine 
   8          *  file.
   9          *
  10          * Note:
  11          *
  12          *******************************************************************************
  13          * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  14          * You may use this file only in accordance with the license, terms, conditions, 
  15          * disclaimers, and limitations in the end user license agreement accompanying 
  16          * the software package with which this file was provided.
  17          *******************************************************************************/
  18          
  19          #include "I2C_Pressure.h"
  20          
  21          
  22          /**********************************
  23          *      System variables
  24          **********************************/
  25          
  26          uint8 I2C_Pressure_initVar = 0u;
  27          extern volatile uint8 I2C_Pressure_state;    /* Current state of I2C state machine */
  28          
  29          /* Master variables */
  30          #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MASTER))
  31             extern volatile uint8 I2C_Pressure_mstrStatus;          /* Master Status byte */
  32             extern volatile uint8 I2C_Pressure_mstrControl;         /* Master Control byte */
  33             
  34             /* Transmit buffer variables */
  35             extern volatile uint8 * I2C_Pressure_mstrRdBufPtr;      /* Pointer to Master Read buffer */
  36             extern volatile uint8   I2C_Pressure_mstrRdBufSize;     /* Master Read buffer size */
  37             extern volatile uint8   I2C_Pressure_mstrRdBufIndex;    /* Master Read buffer Index */
  38              
  39             /* Receive buffer variables */
  40             extern volatile uint8 * I2C_Pressure_mstrWrBufPtr;      /* Pointer to Master Write buffer */
  41             extern volatile uint8   I2C_Pressure_mstrWrBufSize;     /* Master Write buffer size */
  42             extern volatile uint8   I2C_Pressure_mstrWrBufIndex;    /* Master Write buffer Index */
  43             
  44          #endif  /* End (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MASTER)) */
  45          
  46          /* Slave variables */
  47          #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE))
                 extern volatile uint8 I2C_Pressure_slStatus;            /* Slave Status  */
                 
                 #if (I2C_Pressure_ADDR_DECODE == I2C_Pressure_SW_DECODE)
                    extern volatile uint8 I2C_Pressure_slAddress;        /* Software address variable */
                 #endif   /* End (I2C_Pressure_ADDR_DECODE == I2C_Pressure_SW_DECODE) */
                 
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 2   

                 /* Transmit buffer variables */
                 extern volatile uint8 * I2C_Pressure_slRdBufPtr;        /* Pointer to Transmit buffer */
                 extern volatile uint8   I2C_Pressure_slRdBufSize;       /* Slave Transmit buffer size */
                 extern volatile uint8   I2C_Pressure_slRdBufIndex;      /* Slave Transmit buffer Index */
              
                 /* Receive buffer variables */
                 extern volatile uint8 * I2C_Pressure_slWrBufPtr;        /* Pointer to Receive buffer */
                 extern volatile uint8   I2C_Pressure_slWrBufSize;       /* Slave Receive buffer size */
                 extern volatile uint8   I2C_Pressure_slWrBufIndex;      /* Slave Receive buffer Index */
              
              #endif  /* End (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE)) */
  65          
  66          extern I2C_Pressure_BACKUP_STRUCT I2C_Pressure_backup;
  67              
  68          /*******************************************************************************
  69          * Function Name: I2C_Pressure_Init
  70          ********************************************************************************
  71          *
  72          * Summary:
  73          *  Initializes I2C registers with initial values provided from customizer.
  74          *
  75          * Parameters:  
  76          *  None
  77          *
  78          * Return: 
  79          *  None
  80          *
  81          * Global variables:
  82          *  None
  83          *
  84          * Reentrant:
  85          *  No
  86          *
  87          *******************************************************************************/
  88          void I2C_Pressure_Init(void) 
  89          {
  90   1          #if (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_FF)
  91   1              /* Set CFG register */
  92   1              I2C_Pressure_CFG_REG = I2C_Pressure_DEFAULT_CFG;
  93   1              
  94   1              /* Set XCFG register */
  95   1              I2C_Pressure_XCFG_REG = I2C_Pressure_DEFAULT_XCFG;
  96   1              
  97   1              /* Set devide factor */
  98   1              #if (CY_PSOC5A)
                          I2C_Pressure_CLKDIV_REG = I2C_Pressure_DEFAULT_DIVIDE_FACTOR;
                      #else
 101   1                  I2C_Pressure_CLKDIV1_REG = LO8(I2C_Pressure_DEFAULT_DIVIDE_FACTOR);
 102   1                  I2C_Pressure_CLKDIV2_REG = HI8(I2C_Pressure_DEFAULT_DIVIDE_FACTOR);
 103   1              #endif /* End (CY_PSOC5A) */
 104   1              
 105   1          #else
                      uint8 enableInterrupts;
                      
                      /* Set CFG register */
                      I2C_Pressure_CFG_REG = I2C_Pressure_DEFAULT_CFG;
                      
                      /* Set interrupt source: enable Byte Complete interrupt */
                      I2C_Pressure_INT_MASK_REG = I2C_Pressure_BYTE_COMPLETE_IE_MASK;
                      
                      /* Enable interrupts from block */
                      enableInterrupts = CyEnterCriticalSection();
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 3   

                      I2C_Pressure_INT_ENABLE_REG |= I2C_Pressure_INT_ENABLE_MASK;
                      CyExitCriticalSection(enableInterrupts);
                  #endif  /* End (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_FF) */
 119   1          
 120   1          /* Disable Interrupt and set vector and priority */
 121   1          CyIntDisable(I2C_Pressure_ISR_NUMBER);
 122   1          CyIntSetVector(I2C_Pressure_ISR_NUMBER, I2C_Pressure_ISR);
 123   1          CyIntSetPriority(I2C_Pressure_ISR_NUMBER, I2C_Pressure_ISR_PRIORITY);
 124   1          
 125   1          /* Put state machine in idle state */
 126   1          I2C_Pressure_state = I2C_Pressure_SM_IDLE;
 127   1          
 128   1          #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE))
                      /* Reset status and buffer index */
                      I2C_Pressure_SlaveClearReadBuf();
                      I2C_Pressure_SlaveClearWriteBuf();
                      I2C_Pressure_SlaveClearReadStatus();
                      I2C_Pressure_SlaveClearWriteStatus();
                      
                      /* Set default address */
                      I2C_Pressure_SlaveSetAddress(I2C_Pressure_DEFAULT_ADDR);
                  
                  #endif  /* End (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE)) */
 139   1          
 140   1          #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MASTER))
 141   1              /* Reset status and buffer index */
 142   1              I2C_Pressure_MasterClearReadBuf();
 143   1              I2C_Pressure_MasterClearWriteBuf();
 144   1              I2C_Pressure_MasterClearStatus();
 145   1              
 146   1          #endif  /* End (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MASTER)) */
 147   1      }
 148          
 149          
 150          /*******************************************************************************
 151          * Function Name: I2C_Pressure_Enable
 152          ********************************************************************************
 153          *
 154          * Summary:
 155          *  Enables I2C operations.
 156          *
 157          * Parameters:
 158          *  None
 159          *
 160          * Return:
 161          *  None
 162          *
 163          * Global variables:
 164          *  None
 165          *
 166          *******************************************************************************/
 167          void I2C_Pressure_Enable(void) 
 168          {
 169   1          #if ((I2C_Pressure_IMPLEMENTATION != I2C_Pressure_UDB) || \
 170   1              (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE)))
 171   1              uint8 enableInterrupts;
 172   1          #endif  /* End ((I2C_Pressure_IMPLEMENTATION != I2C_Pressure_UDB) || \
 173   1                          (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE)) ) */
 174   1          
 175   1          #if (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_FF)
 176   1              enableInterrupts = CyEnterCriticalSection();
 177   1              /* Enable power to I2C Module */
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 4   

 178   1              I2C_Pressure_ACT_PWRMGR_REG  |= I2C_Pressure_ACT_PWR_EN;
 179   1              I2C_Pressure_STBY_PWRMGR_REG |= I2C_Pressure_STBY_PWR_EN;
 180   1              CyExitCriticalSection(enableInterrupts);
 181   1              
 182   1          #else
                      /* Enable the I2C */
                      I2C_Pressure_CFG_REG |= (I2C_Pressure_ENABLE_MASTER | I2C_Pressure_ENABLE_SLAVE);
                      
                      /* Enable bit counter */
                      #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE))
                          enableInterrupts = CyEnterCriticalSection();
                          /* Enable Counter7 */
                          I2C_Pressure_COUNTER_AUX_CTL_REG |= I2C_Pressure_COUNTER_ENABLE_MASK;
                          CyExitCriticalSection(enableInterrupts);
                      #endif  /* End (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE)) */
                      
                  #endif  /* End (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_FF) */
 195   1      }
 196          
 197          
 198          /*******************************************************************************
 199          * Function Name: I2C_Pressure_Start
 200          ********************************************************************************
 201          *
 202          * Summary:
 203          *  Starts the I2C hardware. Enables Active mode power template bits or clock 
 204          *  gating as appropriate. It is required to be executed before I2C bus operation.
 205          *  The I2C interrupt remains disabled after this function call.
 206          *
 207          * Parameters:
 208          *  None
 209          *
 210          * Return:
 211          *  None
 212          *
 213          * Side Effects:
 214          *  This component automatically enables it's interrupt.  If I2C is enabled
 215          *  without the interrupt enabled, it could lock up the I2C bus.
 216          *
 217          * Global variables:
 218          *  I2C_Pressure_initVar - used to check initial configuration, modified 
 219          *  on first function call.
 220          *
 221          * Reentrant:
 222          *  No
 223          *
 224          *******************************************************************************/
 225          void I2C_Pressure_Start(void) 
 226          {
 227   1          /* Initialize I2C registers, reset I2C buffer index and clears status */
 228   1          if (0u == I2C_Pressure_initVar)
 229   1          {
 230   2              I2C_Pressure_Init();
 231   2              I2C_Pressure_initVar = 1u;
 232   2          }
 233   1          
 234   1          /* Enable component */
 235   1          I2C_Pressure_Enable();
 236   1          
 237   1          /* Enable interrupt */
 238   1          I2C_Pressure_EnableInt();
 239   1      }
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 5   

 240          
 241          
 242          /*******************************************************************************
 243          * Function Name: I2C_Pressure_Stop
 244          ********************************************************************************
 245          *
 246          * Summary:
 247          *  Disables I2C hardware and disables I2C interrupt. Disables Active mode power 
 248          *  template bits or clock gating as appropriate.
 249          *
 250          * Parameters:
 251          *  None 
 252          *
 253          * Return:
 254          *  None
 255          *
 256          *******************************************************************************/
 257          void I2C_Pressure_Stop(void) 
 258          {
 259   1          #if ((I2C_Pressure_IMPLEMENTATION != I2C_Pressure_UDB) || \
 260   1               (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE)))
 261   1              uint8 enableInterrupts;
 262   1          #endif  /* End ( (I2C_Pressure_IMPLEMENTATION != I2C_Pressure_FF) || \
 263   1                         (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE)) ) */
 264   1          
 265   1          /* Disable Interrupt */
 266   1          I2C_Pressure_DisableInt();
 267   1          
 268   1          #if (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_FF)
 269   1              
 270   1              #if (CY_PSOC3 || CY_PSOC5LP)
 271   1                  /* Store resgisters which are held in reset when Master or Slave disabled */
 272   1                  #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE))
                              I2C_Pressure_backup.addr = I2C_Pressure_ADDR_REG;
                          #endif  /* End (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE)) */
 275   1                  
 276   1                  I2C_Pressure_backup.clk_div1  = I2C_Pressure_CLKDIV1_REG;
 277   1                  I2C_Pressure_backup.clk_div2  = I2C_Pressure_CLKDIV2_REG;
 278   1                  
 279   1                  /* Reset the state machine of FF block */
 280   1                  I2C_Pressure_CFG_REG &= ~(I2C_Pressure_ENABLE_MASTER | I2C_Pressure_ENABLE_SLAVE);
 281   1                  
 282   1                  #if (I2C_Pressure_MODE != I2C_Pressure_MODE_SLAVE)
 283   1                      CyDelayUs(2);   /* Delay required for Master reset */
 284   1                  #endif /* End (I2C_Pressure_MODE != I2C_Pressure_MODE_SLAVE) */
 285   1                  
 286   1                  /* Restore registers */
 287   1                  I2C_Pressure_CFG_REG |= (I2C_Pressure_ENABLE_MASTER | I2C_Pressure_ENABLE_SLAVE);
 288   1                  
 289   1                  /* Restore registers */
 290   1                  #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE))
                              I2C_Pressure_ADDR_REG = I2C_Pressure_backup.addr;
                          #endif  /* End (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE)) */
 293   1                  
 294   1                  I2C_Pressure_CLKDIV1_REG = I2C_Pressure_backup.clk_div1;
 295   1                  I2C_Pressure_CLKDIV2_REG = I2C_Pressure_backup.clk_div2;
 296   1                  
 297   1              #endif  /* End (CY_PSOC3 || CY_PSOC5LP) */
 298   1              
 299   1              enableInterrupts = CyEnterCriticalSection();
 300   1              /* Disable power to I2C block */
 301   1              I2C_Pressure_ACT_PWRMGR_REG  &= ~I2C_Pressure_ACT_PWR_EN;
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 6   

 302   1              I2C_Pressure_STBY_PWRMGR_REG &= ~I2C_Pressure_STBY_PWR_EN;
 303   1              CyExitCriticalSection(enableInterrupts);
 304   1          
 305   1          #else
                      /* Clears enable bits in control register */
                      I2C_Pressure_CFG_REG &= ~(I2C_Pressure_ENABLE_MASTER | I2C_Pressure_ENABLE_SLAVE);
                      
                      /* Disable bit counter */
                      #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE))
                          enableInterrupts = CyEnterCriticalSection();
                          /* Disable Counter7 */
                          I2C_Pressure_COUNTER_AUX_CTL_REG &= ~I2C_Pressure_COUNTER_ENABLE_MASK;
                          CyExitCriticalSection(enableInterrupts);
                      #endif  /* End (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE)) */
                      
                  #endif  /* End (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_FF) */
 318   1          
 319   1          /* Clear the interrupt history */
 320   1          CyIntClearPending(I2C_Pressure_ISR_NUMBER);
 321   1          
 322   1          /* Put state machine in IDLE state */
 323   1          I2C_Pressure_state = I2C_Pressure_SM_IDLE;
 324   1          
 325   1          /* Statuses and buffers are not cleared for Slave and Master */
 326   1      }
 327          
 328          
 329          /*******************************************************************************
 330          * Function Name: I2C_Pressure_EnableInt
 331          ********************************************************************************
 332          *
 333          * Summary:
 334          *  This function is implemented as macro in I2C_Pressure.h file.
 335          *  Enables I2C interrupt. Interrupts are required for most operations.
 336          *
 337          * Parameters:
 338          *  None
 339          *
 340          * Return:
 341          *  None
 342          *
 343          *******************************************************************************/
 344          
 345          
 346          /*******************************************************************************
 347          * Function Name: I2C_Pressure_DisableInt
 348          ********************************************************************************
 349          *
 350          * Summary:
 351          *  This function is implemented as macro in I2C_Pressure.h file.
 352          *  Disables I2C interrupts. Normally this function is not required since the 
 353          *  Stop function disables the interrupt. If the I2C interrupt is disabled while 
 354          *  the I2C master is still running, it may cause the I2C bus to lock up.
 355          *
 356          * Parameters:
 357          *  None
 358          *
 359          * Return: 
 360          *  None
 361          *
 362          * Side Effects:
 363          *  If the I2C interrupt is disabled and the master is addressing the current 
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 7   

 364          *  slave, the bus will be locked until the interrupt is re-enabled.
 365          *
 366          *******************************************************************************/
 367          
 368          
 369          #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MASTER))
 370              /*******************************************************************************
 371              * Function Name: I2C_Pressure_MasterStatus
 372              ********************************************************************************
 373              *
 374              * Summary:
 375              *  Returns the master's communication status.
 376              *
 377              * Parameters:
 378              *  None
 379              *
 380              * Return:
 381              *  Current status of I2C master.
 382              *
 383              * Global variables:
 384              *  I2C_Pressure_mstrStatus - used to store current status of I2C Master.
 385              *
 386              *******************************************************************************/
 387              uint8 I2C_Pressure_MasterStatus(void) 
 388              {
 389   1              uint8 status;
 390   1              
 391   1              status = I2C_Pressure_mstrStatus;
 392   1              
 393   1              /* When in Master state only transaction is in progress */
 394   1              if (0u != (I2C_Pressure_state & I2C_Pressure_SM_MASTER))
 395   1              {
 396   2                  /* Add transaction in progress activity to master status */
 397   2                  status |= I2C_Pressure_MSTAT_XFER_INP;
 398   2              }
 399   1              else
 400   1              {
 401   2                  /* Current master status is valid */
 402   2              }
 403   1              
 404   1              return (status);
 405   1          }
 406              
 407              
 408              /*******************************************************************************
 409              * Function Name: I2C_Pressure_MasterClearStatus
 410              ********************************************************************************
 411              *
 412              * Summary:
 413              *  Clears all status flags and returns the master status.
 414              *
 415              * Parameters:
 416              *  None
 417              *
 418              * Return:
 419              *  Current status of I2C master.
 420              *
 421              * Global variables:
 422              *  I2C_Pressure_mstrStatus - used to store current status of I2C Master.
 423              *
 424              * Reentrant:
 425              *  No
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 8   

 426              *
 427              *******************************************************************************/
 428              uint8 I2C_Pressure_MasterClearStatus(void) 
 429              {
 430   1              /* Current master status */
 431   1              uint8 status;
 432   1              
 433   1              /* Read and clear master status */
 434   1              status = I2C_Pressure_mstrStatus;
 435   1              I2C_Pressure_mstrStatus = I2C_Pressure_MSTAT_CLEAR; 
 436   1              
 437   1              return (status);
 438   1          }
 439              
 440              
 441              /*******************************************************************************
 442              * Function Name: I2C_Pressure_MasterWriteBuf
 443              ********************************************************************************
 444              *
 445              * Summary:
 446              *  Automatically writes an entire buffer of data to a slave device. Once the 
 447              *  data transfer is initiated by this function, further data transfer is handled
 448              *  by the included ISR in byte by byte mode.
 449              *
 450              * Parameters:
 451              *  slaveAddr: 7-bit slave address.
 452              *  xferData:  Pointer to buffer of data to be sent.
 453              *  cnt:       Size of buffer to send.
 454              *  mode:      Transfer mode defines: start or restart condition generation at 
 455              *             begin of the transfer and complete the transfer or halt before 
 456              *             generating a stop.
 457              *
 458              * Return:
 459              *  Status error - zero means no errors.
 460              *
 461              * Side Effects:
 462              *  The included ISR will start transfer after start or restart condition will 
 463              *  be generated.
 464              *
 465              * Global variables:
 466              *  I2C_Pressure_mstrStatus  - used to store current status of I2C Master.
 467              *  I2C_Pressure_state       - used to store current state of software FSM.
 468              *  I2C_Pressure_mstrControl - used to control master end of transaction with
 469              *  or without the Stop generation.
 470              *  I2C_Pressure_mstrWrBufPtr - used to store pointer to master write buffer.
 471              *  I2C_Pressure_mstrWrBufIndex - used to current index within master write 
 472              *  buffer.
 473              *  I2C_Pressure_mstrWrBufSize - used to store master write buffer size.
 474              *
 475              * Reentrant:
 476              *  No
 477              *
 478              *******************************************************************************/
 479              uint8 I2C_Pressure_MasterWriteBuf(uint8 slaveAddress, uint8 * xferData, uint8 cnt, uint8 mode)
 480                     
 481              {
 482   1              uint8 errStatus = I2C_Pressure_MSTR_NOT_READY;
 483   1              
 484   1              /* Check for proper buffer */
 485   1              if (NULL != xferData)
 486   1              {
 487   2                  /* Check if I2C in proper state to generate Start/ReStart condition */
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 9   

 488   2                  if ((I2C_Pressure_state == I2C_Pressure_SM_IDLE) || 
 489   2                     (I2C_Pressure_state == I2C_Pressure_SM_MSTR_HALT))
 490   2                  {
 491   3                      /* If IDLE, check if bus is free */
 492   3                      if (I2C_Pressure_state == I2C_Pressure_SM_IDLE)
 493   3                      {
 494   4                          /* If Bus is free proceed, no exist */
 495   4                          if (I2C_Pressure_CHECK_BUS_FREE(I2C_Pressure_MCSR_REG))
 496   4                          {
 497   5                              errStatus = I2C_Pressure_MSTR_NO_ERROR;
 498   5                          }
 499   4                          else
 500   4                          {
 501   5                              errStatus = I2C_Pressure_MSTR_BUS_BUSY;
 502   5                          }
 503   4                      }
 504   3                      else   /* Bus halted waiting for restart */
 505   3                      {
 506   4                          CyIntClearPending(I2C_Pressure_ISR_NUMBER);
 507   4                          I2C_Pressure_mstrStatus &= ~I2C_Pressure_MSTAT_XFER_HALT;
 508   4                          errStatus = I2C_Pressure_MSTR_NO_ERROR;
 509   4                      }
 510   3                      
 511   3                      /* If no errors, generate start */
 512   3                      if (errStatus == I2C_Pressure_MSTR_NO_ERROR)
 513   3                      {
 514   4                          /* Determine whether or not to generate a Stop condition at the end of write */
 515   4                          if (0u != (mode & I2C_Pressure_MODE_NO_STOP))
 516   4                          {
 517   5                              I2C_Pressure_mstrControl |= I2C_Pressure_MSTR_NO_STOP;  /* Without a Stop */
 518   5                          }
 519   4                          else
 520   4                          {
 521   5                              I2C_Pressure_mstrControl &= ~I2C_Pressure_MSTR_NO_STOP; /* Generate a Stop */
 522   5                          }
 523   4                          
 524   4                          I2C_Pressure_state = I2C_Pressure_SM_MSTR_WR_ADDR;  /* Start from address write state 
             -*/
 525   4                          slaveAddress <<= I2C_Pressure_SLAVE_ADDR_SHIFT;         /* Set Address */
 526   4                          I2C_Pressure_DATA_REG = slaveAddress;                   /* Write address to data reg *
             -/
 527   4                          
 528   4                          I2C_Pressure_mstrWrBufIndex = 0u;       /* Start buffer at zero */
 529   4                          I2C_Pressure_mstrWrBufSize  = cnt;      /* Set buffer size */
 530   4                          I2C_Pressure_mstrWrBufPtr   = (volatile uint8 *) xferData; /* Set buffer pointer */
 531   4                          
 532   4                          /* Generate a Start or ReStart depending on flag passed */
 533   4                          if (0u != (mode & I2C_Pressure_MODE_REPEAT_START))
 534   4                          {
 535   5                              I2C_Pressure_GENERATE_RESTART;  /* Generate a ReStart */
 536   5                          }
 537   4                          else
 538   4                          {
 539   5                              I2C_Pressure_GENERATE_START;    /* Generate a Start */
 540   5                          }
 541   4                          
 542   4                          /* Enable interrupts to process transfer */
 543   4                          I2C_Pressure_EnableInt();
 544   4                          
 545   4                          /* Clear write complete flag */
 546   4                          I2C_Pressure_mstrStatus &= ~I2C_Pressure_MSTAT_WR_CMPLT;
 547   4                      }
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 10  

 548   3                  }
 549   2              }
 550   1              
 551   1              return (errStatus);
 552   1          }
 553              
 554              
 555              /*******************************************************************************
 556              * Function Name: I2C_Pressure_MasterReadBuf
 557              ********************************************************************************
 558              *
 559              * Summary:
 560              *  Automatically writes an entire buffer of data to a slave device. Once the 
 561              *  data transfer is initiated by this function, further data transfer is handled
 562              *  by the included ISR in byte by byte mode.  
 563              *
 564              * Parameters:
 565              *  slaveAddr: 7-bit slave address.
 566              *  xferData:  Pointer to buffer where to put data from slave.
 567              *  cnt:       Size of buffer to read.
 568              *  mode:      Transfer mode defines: start or restart condition generation at 
 569              *             begin of the transfer and complete the transfer or halt before 
 570              *             generating a stop.
 571              *
 572              * Return:
 573              *  Status error - zero means no errors.
 574              *
 575              * Side Effects:
 576              *  The included ISR will start transfer after start or restart condition will 
 577              *  be generated.
 578              *
 579              * Global variables:
 580              *  I2C_Pressure_mstrStatus  - used to store current status of I2C Master.
 581              *  I2C_Pressure_state       - used to store current state of software FSM.
 582              *  I2C_Pressure_mstrControl - used to control master end of transaction with
 583              *  or without the Stop generation.
 584              *  I2C_Pressure_mstrRdBufPtr - used to store pointer to master write buffer.
 585              *  I2C_Pressure_mstrRdBufIndex - used to current index within master write 
 586              *  buffer.
 587              *  I2C_Pressure_mstrRdBufSize - used to store master write buffer size.
 588              *
 589              * Reentrant:
 590              *  No
 591              *
 592              *******************************************************************************/
 593              uint8 I2C_Pressure_MasterReadBuf(uint8 slaveAddress, uint8 * xferData, uint8 cnt, uint8 mode)
 594                    
 595              {
 596   1              uint8 errStatus = I2C_Pressure_MSTR_NOT_READY;
 597   1              
 598   1              /* Check for proper buffer */
 599   1              if (NULL != xferData)
 600   1              {
 601   2                  /* Check if I2C in proper state to generate Start/ReStart condition */
 602   2                  if ((I2C_Pressure_state == I2C_Pressure_SM_IDLE) ||
 603   2                     (I2C_Pressure_state == I2C_Pressure_SM_MSTR_HALT))
 604   2                  {
 605   3                      /* If IDLE, check if bus is free */
 606   3                      if (I2C_Pressure_state == I2C_Pressure_SM_IDLE)
 607   3                      {
 608   4                          /* If Bus is free proceed, no exist */
 609   4                          if (I2C_Pressure_CHECK_BUS_FREE(I2C_Pressure_MCSR_REG))
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 11  

 610   4                          {
 611   5                              errStatus = I2C_Pressure_MSTR_NO_ERROR;
 612   5                          }
 613   4                          else
 614   4                          {
 615   5                              errStatus = I2C_Pressure_MSTR_BUS_BUSY;
 616   5                          }
 617   4                      }
 618   3                      else   /* Bus halted waiting for restart */
 619   3                      {
 620   4                          CyIntClearPending(I2C_Pressure_ISR_NUMBER);
 621   4                          I2C_Pressure_mstrStatus &= ~I2C_Pressure_MSTAT_XFER_HALT;
 622   4                          errStatus = I2C_Pressure_MSTR_NO_ERROR;
 623   4                      }
 624   3                      
 625   3                      /* If no error, generate Start/ReStart condition */
 626   3                      if (errStatus == I2C_Pressure_MSTR_NO_ERROR)
 627   3                      {
 628   4                          /* Determine whether or not to generate a Stop condition at the end of read */
 629   4                          if (0u != (mode & I2C_Pressure_MODE_NO_STOP))
 630   4                          {
 631   5                              I2C_Pressure_mstrControl |= I2C_Pressure_MSTR_NO_STOP;   /* Without Stop */
 632   5                          }
 633   4                          else
 634   4                          {
 635   5                              I2C_Pressure_mstrControl &= ~I2C_Pressure_MSTR_NO_STOP; /* Generate a Stop */
 636   5                          }
 637   4                          
 638   4                          I2C_Pressure_state = I2C_Pressure_SM_MSTR_RD_ADDR;  /* Start from address read state *
             -/ 
 639   4                          slaveAddress <<= I2C_Pressure_SLAVE_ADDR_SHIFT;         /* Set Address */
 640   4                          slaveAddress |= I2C_Pressure_READ_FLAG;                 /* Set the Read flag */
 641   4                          I2C_Pressure_DATA_REG = slaveAddress;                   /* Write address to data reg *
             -/
 642   4                          
 643   4                          I2C_Pressure_mstrRdBufIndex  = 0u;      /* Start buffer at zero */
 644   4                          I2C_Pressure_mstrRdBufSize   = cnt;     /* Set buffer size */
 645   4                          I2C_Pressure_mstrRdBufPtr    = (volatile uint8 *) xferData; /* Set buffer pointer */
 646   4                          
 647   4                          /* Generate a Start or ReStart depending on flag passed */
 648   4                          if (0u != (mode & I2C_Pressure_MODE_REPEAT_START))
 649   4                          {
 650   5                              I2C_Pressure_GENERATE_RESTART;  /* Generate a ReStart */
 651   5                          }
 652   4                          else
 653   4                          {
 654   5                              I2C_Pressure_GENERATE_START;    /* Generate a Start */
 655   5                          }
 656   4                          
 657   4                          /* Enable interrupts to process transfer */
 658   4                          I2C_Pressure_EnableInt();
 659   4                          
 660   4                          /* Clear read complete flag */
 661   4                          I2C_Pressure_mstrStatus &= ~I2C_Pressure_MSTAT_RD_CMPLT;
 662   4                      }
 663   3                  }
 664   2              }
 665   1              
 666   1              return (errStatus);
 667   1          }
 668              
 669              
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 12  

 670              /*******************************************************************************
 671              * Function Name: I2C_Pressure_MasterSendStart
 672              ********************************************************************************
 673              *
 674              * Summary:
 675              *  Generates Start condition and sends slave address with read/write bit.
 676              *
 677              * Parameters:  
 678              *  slaveAddress:  7-bit slave address.
 679              *  R_nW:          Zero, send write command, non-zero send read command.
 680              *
 681              * Return: 
 682              *  Status error - zero means no errors.
 683              *
 684              * Side Effects:
 685              *  This function is entered without a 'byte complete' bit set in the I2C_CSR 
 686              *  register. It does not exit until it will be set.
 687              *
 688              * Global variables:
 689              *  I2C_Pressure_state - used to store current state of software FSM.
 690              *
 691              * Reentrant:
 692              *  No
 693              *
 694              *******************************************************************************/
 695              uint8 I2C_Pressure_MasterSendStart(uint8 slaveAddress, uint8 R_nW)
 696                    
 697              {
 698   1              uint8 errStatus = I2C_Pressure_MSTR_NOT_READY;
 699   1              
 700   1              /* If IDLE, check if bus is free */
 701   1              if (I2C_Pressure_state == I2C_Pressure_SM_IDLE)
 702   1              {
 703   2                  /* If bus is free, generate Start condition */
 704   2                  if (I2C_Pressure_CHECK_BUS_FREE(I2C_Pressure_MCSR_REG))
 705   2                  {
 706   3                      /* Disable ISR for Manual functions */
 707   3                      I2C_Pressure_DisableInt();
 708   3                      
 709   3                      slaveAddress <<= I2C_Pressure_SLAVE_ADDR_SHIFT; /* Set Address */
 710   3                      if (0u != R_nW)                                      /* Set the Read/Write flag */
 711   3                      {
 712   4                          slaveAddress |= I2C_Pressure_READ_FLAG;
 713   4                          I2C_Pressure_state = I2C_Pressure_SM_MSTR_RD_ADDR;
 714   4                      }
 715   3                      else
 716   3                      {
 717   4                          I2C_Pressure_state = I2C_Pressure_SM_MSTR_WR_ADDR;
 718   4                      }
 719   3                      I2C_Pressure_DATA_REG = slaveAddress;   /* Write address to data reg */
 720   3                      
 721   3                      /* Generates a START */
 722   3                      I2C_Pressure_GENERATE_START;
 723   3                      
 724   3                      /* Wait for the address to be transfered */
 725   3                      while (I2C_Pressure_WAIT_BYTE_COMPLETE(I2C_Pressure_CSR_REG));
 726   3                      
 727   3                      #if (I2C_Pressure_MODE == I2C_Pressure_MODE_MULTI_MASTER_SLAVE)
                                  if (I2C_Pressure_CHECK_START_GEN(I2C_Pressure_MCSR_REG))
                                  {
                                      /* Clear Start Gen bit */
                                      I2C_Pressure_CLEAR_START_GEN;
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 13  

                                      
                                      /* Arbitration has been lost, reset state machine to IDLE */
                                      I2C_Pressure_state = I2C_Pressure_SM_IDLE;
                                      errStatus = I2C_Pressure_MSTR_ERR_ABORT_START_GEN;
                                  }
                                  else
                              #endif  /* End (I2C_Pressure_MODE == I2C_Pressure_MULTI_MASTER_ENABLE) */
 739   3                          
 740   3                      #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MULTI_MASTER_ENABLE))
                                  /* Check for loss of arbitration */
                                  if (I2C_Pressure_CHECK_LOST_ARB(I2C_Pressure_CSR_REG))
                                  {
                                      /* Arbitration has been lost, reset state machine to IDLE */
                                      I2C_Pressure_state = I2C_Pressure_SM_IDLE;
                                      errStatus = I2C_Pressure_MSTR_ERR_ARB_LOST; /* Master lost arbitrage */
                                  }
                                  else
                              #endif  /* (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MULTI_MASTER_ENABLE)) */
 750   3                          
 751   3                          if (I2C_Pressure_CHECK_ADDR_NAK(I2C_Pressure_CSR_REG))
 752   3                          {
 753   4                              /* Address has been NACKed, reset state machine to IDLE */
 754   4                              I2C_Pressure_state = I2C_Pressure_SM_IDLE;
 755   4                              errStatus = I2C_Pressure_MSTR_ERR_LB_NAK;    /* No device ACKed the Master */
 756   4                          }
 757   3                          else
 758   3                          {
 759   4                              errStatus = I2C_Pressure_MSTR_NO_ERROR;     /* Send Start witout errors */
 760   4                          }
 761   3                  }
 762   2                  else
 763   2                  {
 764   3                      errStatus = I2C_Pressure_MSTR_BUS_BUSY;     /* Bus is busy */
 765   3                  }
 766   2              }
 767   1              
 768   1              return (errStatus);
 769   1          }
 770              
 771              
 772              /*******************************************************************************
 773              * Function Name: I2C_Pressure_MasterSendRestart
 774              ********************************************************************************
 775              *
 776              * Summary:
 777              *  Generates ReStart condition and sends slave address with read/write bit.
 778              *
 779              * Parameters:  
 780              *  slaveAddress:  7-bit slave address.
 781              *  R_nW:          Zero, send write command, non-zero send read command.
 782              *
 783              * Return: 
 784              *  Status error - zero means no errors.
 785              *
 786              * Side Effects:
 787              *  This function is entered without a 'byte complete' bit set in the I2C_CSR 
 788              *  register. It does not exit until it will be set.
 789              *
 790              * Global variables:
 791              *  I2C_Pressure_state - used to store current state of software FSM.
 792              *
 793              * Reentrant:
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 14  

 794              *  No
 795              *
 796              *******************************************************************************/
 797              uint8 I2C_Pressure_MasterSendRestart(uint8 slaveAddress, uint8 R_nW)
 798                    
 799              {
 800   1              uint8 errStatus = I2C_Pressure_MSTR_NOT_READY;
 801   1              
 802   1              /* Check if START condition was generated */
 803   1              if (I2C_Pressure_CHECK_MASTER_MODE(I2C_Pressure_MCSR_REG))
 804   1              {
 805   2                  slaveAddress <<= I2C_Pressure_SLAVE_ADDR_SHIFT; /* Set Address */
 806   2                  if (0u != R_nW)                                      /* Set the Read/Write flag */
 807   2                  {
 808   3                      slaveAddress |= I2C_Pressure_READ_FLAG;
 809   3                      I2C_Pressure_state = I2C_Pressure_SM_MSTR_RD_ADDR;
 810   3                  }
 811   2                  else
 812   2                  {
 813   3                      I2C_Pressure_state = I2C_Pressure_SM_MSTR_WR_ADDR;
 814   3                  }
 815   2                  I2C_Pressure_DATA_REG = slaveAddress;    /* Write address to data reg */
 816   2                  
 817   2                  /* Generates RESTART */
 818   2                  I2C_Pressure_GENERATE_RESTART;
 819   2                  #if (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_UDB)
                              while (I2C_Pressure_CHECK_BYTE_COMPLETE(I2C_Pressure_CSR_REG));
                          #endif /* End (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_UDB) */
 822   2                  
 823   2                  /* Wait for the address to be transfered */
 824   2                  while (I2C_Pressure_WAIT_BYTE_COMPLETE(I2C_Pressure_CSR_REG));
 825   2                  
 826   2                  #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MULTI_MASTER_ENABLE))
                              /* Check for loss of arbitration */
                              if (I2C_Pressure_CHECK_LOST_ARB(I2C_Pressure_CSR_REG))
                              {
                                  /* Arbitration has been lost, reset state machine to IDLE */
                                  I2C_Pressure_state = I2C_Pressure_SM_IDLE;
                                  errStatus = I2C_Pressure_MSTR_ERR_ARB_LOST; /* Master lost arbitrage */
                              }
                              else
                          #endif  /* End (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MULTI_MASTER_ENABLE)) */    
 836   2                  
 837   2                      /* Check ACK address if Master mode */
 838   2                      if (I2C_Pressure_CHECK_ADDR_NAK(I2C_Pressure_CSR_REG))
 839   2                      {
 840   3                          /* Address has been NACKed, reset state machine to IDLE */
 841   3                          I2C_Pressure_state = I2C_Pressure_SM_IDLE;
 842   3                          errStatus = I2C_Pressure_MSTR_ERR_LB_NAK;    /* No device ACKed the Master */
 843   3                      }
 844   2                      else
 845   2                      {
 846   3                          errStatus = I2C_Pressure_MSTR_NO_ERROR;     /* Send START witout errors */
 847   3                      }
 848   2              }
 849   1              
 850   1              return (errStatus);
 851   1          }
 852              
 853              
 854              /*******************************************************************************
 855              * Function Name: I2C_Pressure_MasterSendStop
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 15  

 856              ********************************************************************************
 857              *
 858              * Summary:
 859              *  Generates I2C Stop condition on bus. Function do nothing if Start or Restart 
 860              *  condition was failed before call this function.
 861              *
 862              * Parameters:  
 863              *  None
 864              *
 865              * Return: 
 866              *  Status error - zero means no errors.
 867              *
 868              * Side Effects:
 869              *  The Stop generation is required to complete transaction.
 870              *  This function does not wait while Stop condition will be generated.
 871              *
 872              * Global variables:
 873              *  I2C_Pressure_state - used to store current state of software FSM.
 874              *
 875              * Reentrant:
 876              *  No
 877              *
 878              *******************************************************************************/
 879              uint8 I2C_Pressure_MasterSendStop(void) 
 880              {
 881   1              uint8 errStatus = I2C_Pressure_MSTR_NOT_READY;
 882   1              
 883   1              /* Check if START condition was generated */
 884   1              if (I2C_Pressure_CHECK_MASTER_MODE(I2C_Pressure_MCSR_REG))
 885   1              {
 886   2                  I2C_Pressure_GENERATE_STOP;                     /* Generate STOP */
 887   2                  I2C_Pressure_state = I2C_Pressure_SM_IDLE; /* Reset state to IDLE */
 888   2                  errStatus = I2C_Pressure_MSTR_NO_ERROR;         /* Start send STOP witout errors */
 889   2                      
 890   2                  /* Wait for STOP generation or BYTE COMPLETE (lost arbitrage) */
 891   2                  #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MULTI_MASTER_ENABLE))
                              
                              #if (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_UDB)
                                  while (I2C_Pressure_CHECK_BYTE_COMPLETE(I2C_Pressure_CSR_REG));
                              #endif /* End (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_UDB) */
                              
                              while (0u == (I2C_Pressure_CSR_REG & (I2C_Pressure_CSR_BYTE_COMPLETE |
                                                                       I2C_Pressure_CSR_STOP_STATUS)));
                              
                              /* Check LOST ARBITRAGE */
                              if (I2C_Pressure_CHECK_LOST_ARB(I2C_Pressure_CSR_REG))
                              {
                                  errStatus = I2C_Pressure_MSTR_ERR_ARB_LOST; /* NACK was generated instead Stop */
                              }
                              /* STOP condition generated */
                              else
                              {
                                  errStatus = I2C_Pressure_MSTR_NO_ERROR;     /* Stop was generated */
                              }
                          #else
 911   2                      /* Wait till Stop will be generated */
 912   2                      while (0u == (I2C_Pressure_CSR_REG & I2C_Pressure_CSR_STOP_STATUS));
 913   2                  #endif  /* End (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MULTI_MASTER_ENABLE)) */
 914   2              }
 915   1              
 916   1              return (errStatus);
 917   1          }
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 16  

 918              
 919              
 920              /*******************************************************************************
 921              * Function Name: I2C_Pressure_MasterWriteByte
 922              ********************************************************************************
 923              *
 924              * Summary:
 925              *  Sends one byte to a slave. A valid Start or ReStart condition must be 
 926              *  generated before this call this function. Function do nothing if Start or 
 927              *  Restart condition was failed before call this function.
 928              *
 929              * Parameters:
 930              *  data:  The data byte to send to the slave.
 931              *
 932              * Return:
 933              *  Status error - zero means no errors.
 934              *
 935              * Side Effects:
 936              *  This function is entered without a 'byte complete' bit set in the I2C_CSR 
 937              *  register. It does not exit until it will be set.
 938              *
 939              * Global variables:
 940              *  I2C_Pressure_state - used to store current state of software FSM.
 941              *
 942              *******************************************************************************/
 943              uint8 I2C_Pressure_MasterWriteByte(uint8 theByte) 
 944              {
 945   1              uint8 errStatus = I2C_Pressure_MSTR_NOT_READY;
 946   1              
 947   1              /* Check if START condition was generated */
 948   1              if (I2C_Pressure_CHECK_MASTER_MODE(I2C_Pressure_MCSR_REG))
 949   1              {
 950   2                  I2C_Pressure_DATA_REG = theByte;                        /* Write DATA register */
 951   2                  I2C_Pressure_TRANSMIT_DATA;                             /* Set transmit mode */
 952   2                  I2C_Pressure_state = I2C_Pressure_SM_MSTR_WR_DATA;  /* Set state WR_DATA */
 953   2                  #if (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_UDB)
                              while (I2C_Pressure_CHECK_BYTE_COMPLETE(I2C_Pressure_CSR_REG));
                          #endif
 956   2                  
 957   2                  /* Make sure the last byte has been transfered first */
 958   2                  while (I2C_Pressure_WAIT_BYTE_COMPLETE(I2C_Pressure_CSR_REG));
 959   2                  
 960   2                  #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MULTI_MASTER_ENABLE))
                              /* Check for LOST ARBITRATION */
                              if (I2C_Pressure_CHECK_LOST_ARB(I2C_Pressure_CSR_REG))
                              {
                                  /* Arbitration has been lost, reset state machine to IDLE */
                                  I2C_Pressure_state = I2C_Pressure_SM_IDLE;          /* Reset state to IDLE */
                                  errStatus = I2C_Pressure_MSTR_ERR_ARB_LOST;             /* The Master LOST ARBITRAGE *
             -/
                              }
                              /* Check LRB bit */
                              else 
                          #endif  /* End (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MULTI_MASTER_ENABLE)) */
 971   2                  
 972   2                      if (I2C_Pressure_CHECK_DATA_ACK(I2C_Pressure_CSR_REG))
 973   2                      {
 974   3                          I2C_Pressure_state = I2C_Pressure_SM_MSTR_HALT;     /* Set state to HALT */
 975   3                          errStatus = I2C_Pressure_MSTR_NO_ERROR;                 /* The LRB was ACKed */
 976   3                      }
 977   2                      else
 978   2                      {
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 17  

 979   3                          I2C_Pressure_state = I2C_Pressure_SM_MSTR_HALT;     /* Set state to HALT */
 980   3                          errStatus = I2C_Pressure_MSTR_ERR_LB_NAK;               /* The LRB was NACKed */
 981   3                      }
 982   2              }
 983   1              
 984   1              return (errStatus);
 985   1          }
 986              
 987              
 988              /*******************************************************************************
 989              * Function Name: I2C_Pressure_MasterReadByte
 990              ********************************************************************************
 991              *
 992              * Summary:
 993              *  Reads one byte from a slave and ACK or NACK the transfer. A valid Start or 
 994              *  ReStart condition must be generated before this call this function. Function
 995              *  do nothing if Start or Restart condition was failed before call this 
 996              *  function.
 997              *
 998              * Parameters:
 999              *  acknNack:  Zero, response with NACK, if non-zero response with ACK.
1000              *
1001              * Return:
1002              *  Byte read from slave.
1003              *
1004              * Side Effects:
1005              *  This function is entered without a 'byte complete' bit set in the I2C_CSR 
1006              *  register. It does not exit until it will be set.
1007              *
1008              * Global variables:
1009              *  I2C_Pressure_state - used to store current state of software FSM.
1010              *
1011              * Reentrant:
1012              *  No
1013              *
1014              *******************************************************************************/
1015              uint8 I2C_Pressure_MasterReadByte(uint8 acknNak) 
1016              {
1017   1              uint8 theByte = 0u;
1018   1              
1019   1              /* Check if START condition was generated */
1020   1              if (I2C_Pressure_CHECK_MASTER_MODE(I2C_Pressure_MCSR_REG))
1021   1              {
1022   2                  /* When address phase need release the bus and receive the byte, then decide ACK or NACK */
1023   2                  if (I2C_Pressure_state == I2C_Pressure_SM_MSTR_RD_ADDR)
1024   2                  {
1025   3                      I2C_Pressure_READY_TO_READ;
1026   3                      I2C_Pressure_state = I2C_Pressure_SM_MSTR_RD_DATA;
1027   3                      #if (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_UDB)
                                  while (I2C_Pressure_CHECK_BYTE_COMPLETE(I2C_Pressure_CSR_REG));
                              #endif /* End (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_UDB) */
1030   3                  }
1031   2                  
1032   2                  while (I2C_Pressure_WAIT_BYTE_COMPLETE(I2C_Pressure_CSR_REG));
1033   2                  
1034   2                  theByte = I2C_Pressure_DATA_REG;
1035   2                  
1036   2                  /* Now if the ACK flag was set, ACK the data which will release the bus and start the next byt
             -e in
1037   2                     otherwise do NOTHING to the CSR reg.
1038   2                     This will allow the calling routine to generate a repeat start or a stop depending on it's 
             -preference. */
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 18  

1039   2                  if (acknNak != 0u)   /* Do ACK */
1040   2                  {
1041   3                      I2C_Pressure_ACK_AND_RECEIVE;
1042   3                      #if (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_UDB)
                                  while (I2C_Pressure_CHECK_BYTE_COMPLETE(I2C_Pressure_CSR_REG));
                              #endif /* End (I2C_Pressure_IMPLEMENTATION == I2C_Pressure_UDB) */
1045   3                  }
1046   2                  else                /* Do NACK */
1047   2                  {
1048   3                      /* Do nothing to be able work with ReStart */
1049   3                      I2C_Pressure_state = I2C_Pressure_SM_MSTR_HALT;
1050   3                  }
1051   2              }
1052   1              
1053   1              return (theByte);
1054   1          }
1055              
1056              
1057              /*******************************************************************************
1058              * Function Name: I2C_Pressure_MasterGetReadBufSize
1059              ********************************************************************************
1060              *
1061              * Summary:
1062              *  Returns the amount of bytes that has been transferred with an 
1063              *  I2C_MasterReadBuf command.
1064              *
1065              * Parameters:
1066              *  None
1067              *
1068              * Return:
1069              *  Byte count of transfer. If the transfer is not yet complete, it will return 
1070              *  the byte count transferred so far.
1071              *
1072              * Global variables:
1073              *  I2C_Pressure_mstrRdBufIndex - used to current index within master read 
1074              *  buffer.
1075              *
1076              *******************************************************************************/
1077              uint8 I2C_Pressure_MasterGetReadBufSize(void) 
1078              {
1079   1              return (I2C_Pressure_mstrRdBufIndex);
1080   1          }
1081              
1082              
1083              /*******************************************************************************
1084              * Function Name: I2C_Pressure_MasterGetWriteBufSize
1085              ********************************************************************************
1086              *
1087              * Summary:
1088              *  Returns the amount of bytes that has been transferred with an 
1089              *  I2C_MasterWriteBuf command.
1090              *
1091              * Parameters:
1092              *  None
1093              *
1094              * Return:
1095              *  Byte count of transfer. If the transfer is not yet complete, it will return 
1096              *  the byte count transferred so far.
1097              *
1098              * Global variables:
1099              *  I2C_Pressure_mstrWrBufIndex - used to current index within master write 
1100              *  buffer.
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 19  

1101              *
1102              *******************************************************************************/
1103              uint8 I2C_Pressure_MasterGetWriteBufSize(void) 
1104              {
1105   1              return (I2C_Pressure_mstrWrBufIndex);
1106   1          }
1107              
1108              
1109              /*******************************************************************************
1110              * Function Name: I2C_Pressure_MasterClearReadBuf
1111              ********************************************************************************
1112              *
1113              * Summary:
1114              *  Resets the read buffer pointer back to the first byte in the buffer.
1115              *
1116              * Parameters:
1117              *  None
1118              *
1119              * Return:
1120              *  None
1121              *
1122              * Global variables:
1123              *  I2C_Pressure_mstrRdBufIndex - used to current index within master read 
1124              *   buffer.
1125              *  I2C_Pressure_mstrStatus - used to store current status of I2C Master.
1126              *
1127              * Reentrant:
1128              *  No
1129              *
1130              *******************************************************************************/
1131              void I2C_Pressure_MasterClearReadBuf(void) 
1132              {
1133   1              I2C_Pressure_mstrRdBufIndex = 0u;
1134   1              I2C_Pressure_mstrStatus &= ~I2C_Pressure_MSTAT_RD_CMPLT;
1135   1          }
1136              
1137              
1138              /*******************************************************************************
1139              * Function Name: I2C_Pressure_MasterClearWriteBuf
1140              ********************************************************************************
1141              *
1142              * Summary:
1143              *  Resets the write buffer pointer back to the first byte in the buffer.
1144              *
1145              * Parameters:
1146              *  None
1147              *
1148              * Return:
1149              *  None
1150              *
1151              * Global variables:
1152              *  I2C_Pressure_mstrRdBufIndex - used to current index within master read 
1153              *   buffer.
1154              *  I2C_Pressure_mstrStatus - used to store current status of I2C Master.
1155              *
1156              * Reentrant:
1157              *  No
1158              *
1159              *******************************************************************************/
1160              void I2C_Pressure_MasterClearWriteBuf(void) 
1161              {
1162   1              I2C_Pressure_mstrWrBufIndex = 0u;
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 20  

1163   1              I2C_Pressure_mstrStatus &= ~I2C_Pressure_MSTAT_WR_CMPLT;
1164   1          }
1165              
1166              
1167              /*******************************************************************************
1168              * Function Name: I2C_Pressure_Workaround
1169              ********************************************************************************
1170              *
1171              * Summary:
1172              *  Do nothing. This fake fuction use as workaround for CDT 78083.
1173              *
1174              * Parameters:
1175              *  None
1176              *
1177              * Return:
1178              *  None
1179              *
1180              * Reentrant:
1181              *  No
1182              *
1183              *******************************************************************************/
1184              void I2C_Pressure_Workaround(void) 
1185              {
1186   1          
1187   1          }
1188              
1189          #endif  /* End (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_MASTER)) */
1190          
1191          
1192          #if (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE))
              
                  /*******************************************************************************
                  * Function Name: I2C_Pressure_SlaveStatus
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns I2C slave's communication status.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Current status of I2C slave.
                  *
                  * Global variables:
                  *  I2C_Pressure_slStatus  - used to store current status of I2C slave.
                  *
                  *******************************************************************************/
                  uint8 I2C_Pressure_SlaveStatus(void) 
                  {
                      return (I2C_Pressure_slStatus);
                  }
                  
                  
                  /*******************************************************************************
                  * Function Name: I2C_Pressure_SlaveClearReadStatus
                  ********************************************************************************
                  *
                  * Summary:
                  *  Clears the read status flags and returns they values. No other status flags 
                  *  are affected.
                  *
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 21  

                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Current read status of I2C slave.
                  *
                  * Global variables:
                  *  I2C_Pressure_slStatus  - used to store current status of I2C slave.
                  *
                  * Reentrant:
                  *  No
                  *
                  *******************************************************************************/
                  uint8 I2C_Pressure_SlaveClearReadStatus(void) 
                  {
                      uint8 status;
                      
                      /* Mask of transfer complete flag and Error status */
                      status = I2C_Pressure_slStatus & I2C_Pressure_SSTAT_RD_MASK;
                      I2C_Pressure_slStatus &= ~I2C_Pressure_SSTAT_RD_CLEAR;
                      
                      return (status);
                  }
                  
                  
                  /*******************************************************************************
                  * Function Name: I2C_Pressure_SlaveClearWriteStatus
                  ********************************************************************************
                  *
                  * Summary:
                  *  Clears the write status flags and returns they values. No other status flags
                  *  are affected.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Current write status of I2C slave.
                  *
                  * Global variables:
                  *  I2C_Pressure_slStatus  - used to store current status of I2C slave.
                  *
                  * Reentrant:
                  *  No
                  *
                  *******************************************************************************/
                  uint8 I2C_Pressure_SlaveClearWriteStatus(void) 
                  {
                      uint8 status;
                      
                      /* Mask of transfer complete flag and Error status */
                      status = I2C_Pressure_slStatus & I2C_Pressure_SSTAT_WR_MASK;
                      I2C_Pressure_slStatus &= ~I2C_Pressure_SSTAT_WR_CLEAR;
                      
                      return (status);
                  }
                  
                  
                  /*******************************************************************************
                  * Function Name: I2C_Pressure_SlaveSetAddress
                  ********************************************************************************
                  *
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 22  

                  * Summary:
                  *  Sets the I2C slave address.
                  *
                  * Parameters:
                  *  address: I2C slave address for the primary device. This value may be any 
                  *  address between 0 and 127.
                  *
                  * Return:
                  *  None
                  *
                  * Global variables:
                  *  I2C_Pressure_Address  - used to store I2C slave address for the primary 
                  *  device when software address detect feature is used.
                  *
                  * Reentrant:
                  *  No
                  *
                  *******************************************************************************/
                  void I2C_Pressure_SlaveSetAddress(uint8 address) 
                  {
                      #if (I2C_Pressure_ADDR_DECODE == I2C_Pressure_HDWR_DECODE)
                          I2C_Pressure_ADDR_REG = address & I2C_Pressure_SLAVE_ADDR_MASK; /* Set I2C Address register */
                      #else
                          I2C_Pressure_slAddress = address & I2C_Pressure_SLAVE_ADDR_MASK;  /* Set Address variable */ 
                      #endif  /* End (I2C_Pressure_ADDR_DECODE == I2C_Pressure_HDWR_DECODE) */ 
                  }
                      
                  
                  /*******************************************************************************
                  * Function Name: I2C_Pressure_SlaveInitReadBuf
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the buffer pointer and size of the read buffer. This function also 
                  *  resets the transfer count returned with the I2C_SlaveGetReadBufSize function.
                  *
                  * Parameters:
                  *  readBuf:  Pointer to the data buffer to be read by the master.
                  *  bufSize:  Size of the read buffer exposed to the I2C master.
                  *
                  * Return:
                  *  None
                  *
                  * Global variables:
                  *  I2C_Pressure_slRdBufPtr   - used to store pointer to slave read buffer.
                  *  I2C_Pressure_slRdBufSize  - used to store salve read buffer size.
                  *  I2C_Pressure_slRdBufIndex - used to store current index within slave
                  *  read buffer.
                  *
                  * Side Effects:
                  *  If this function is called during a bus transaction, data from the previous 
                  *  buffer location and the beginning of current buffer may be transmitted.
                  *
                  * Reentrant:
                  *  No
                  *
                  *******************************************************************************/
                  void I2C_Pressure_SlaveInitReadBuf(uint8 * readBuf, uint8 bufSize)
                       
                  {
                      /* Check for proper buffer */
                      if (NULL != readBuf)
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 23  

                      {
                          I2C_Pressure_slRdBufPtr   = (volatile uint8 *) readBuf;    /* Set buffer pointer */
                          I2C_Pressure_slRdBufSize  = bufSize;    /* Set buffer size */
                          I2C_Pressure_slRdBufIndex = 0u;         /* Clears buffer index */
                      }
                  }
                  
                  
                  /*******************************************************************************
                  * Function Name: I2C_Pressure_SlaveInitWriteBuf
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the buffer pointer and size of the read buffer. This function also 
                  *  resets the transfer count returned with the I2C_SlaveGetReadBufSize function.
                  *
                  * Parameters:
                  *  writeBuf:  Pointer to the data buffer to be read by the master.
                  *  bufSize:  Size of the buffer exposed to the I2C master.
                  *
                  * Return:
                  *  None
                  *
                  * Global variables:
                  *  I2C_Pressure_slWrBufPtr   - used to store pointer to slave write buffer.
                  *  I2C_Pressure_slWrBufSize  - used to store salve write buffer size.
                  *  I2C_Pressure_slWrBufIndex - used to store current index within slave
                  *  write buffer.
                  *
                  * Side Effects:
                  *  If this function is called during a bus transaction, data from the previous 
                  *  buffer location and the beginning of current buffer may be transmitted.
                  *
                  * Reentrant:
                  *  No
                  *
                  *******************************************************************************/
                  void I2C_Pressure_SlaveInitWriteBuf(uint8 * writeBuf, uint8 bufSize)
                       
                  {
                      /* Check for proper buffer */
                      if (NULL != writeBuf)
                      {
                          I2C_Pressure_slWrBufPtr   = (volatile uint8 *) writeBuf;  /* Set buffer pointer */
                          I2C_Pressure_slWrBufSize  = bufSize;   /* Set buffer size */
                          I2C_Pressure_slWrBufIndex = 0u;        /* Clears buffer index */
                      }
                  }
                  
                  
                  /*******************************************************************************
                  * Function Name: I2C_Pressure_SlaveGetReadBufSize
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns the number of bytes read by the I2C master since an 
                  *  I2C_SlaveInitReadBuf or I2C_SlaveClearReadBuf function was executed. 
                  *  The maximum return value will be the size of the read buffer.
                  *
                  * Parameters:
                  *  None
                  *
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 24  

                  * Return:
                  *  Bytes read by master.
                  *
                  * Global variables:
                  *  I2C_Pressure_slRdBufIndex - used to store current index within slave
                  *  read buffer.
                  *
                  *******************************************************************************/
                  uint8 I2C_Pressure_SlaveGetReadBufSize(void) 
                  {
                      return (I2C_Pressure_slRdBufIndex);
                  }
                  
                  
                  /*******************************************************************************
                  * Function Name: I2C_Pressure_SlaveGetWriteBufSize
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns the number of bytes written by the I2C master since an 
                  *  I2C_SlaveInitWriteBuf or I2C_SlaveClearWriteBuf function was executed.
                  *  The maximum return value will be the size of the write buffer.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Bytes written by master.
                  *
                  * Global variables:
                  *  I2C_Pressure_slWrBufIndex - used to store current index within slave
                  *  write buffer.
                  *
                  *******************************************************************************/
                  uint8 I2C_Pressure_SlaveGetWriteBufSize(void) 
                  {
                      return (I2C_Pressure_slWrBufIndex);
                  }
                  
                  
                  /*******************************************************************************
                  * Function Name: I2C_Pressure_SlaveClearReadBuf
                  ********************************************************************************
                  *
                  * Summary:
                  *  Resets the read pointer to the first byte in the read buffer. The next byte 
                  *  read by the master will be the first byte in the read buffer.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Global variables:
                  *  I2C_Pressure_slRdBufIndex - used to store current index within slave
                  *  read buffer.
                  *
                  * Reentrant:
                  *  No
                  *
                  *******************************************************************************/
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 25  

                  void I2C_Pressure_SlaveClearReadBuf(void)  
                  {
                      I2C_Pressure_slRdBufIndex = 0u;
                  }
                  
                  
                  /*******************************************************************************
                  * Function Name: I2C_Pressure_SlaveClearRxBuf
                  ********************************************************************************
                  *
                  * Summary:
                  *  Resets the write pointer to the first byte in the write buffer. The next byte
                  *  written by the master will be the first byte in the write buffer.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Global variables:
                  *  I2C_Pressure_slWrBufIndex - used to store current index within slave
                  *  write buffer.
                  *
                  * Reentrant:
                  *  No
                  *
                  *******************************************************************************/
                  void I2C_Pressure_SlaveClearWriteBuf(void)  
                  {
                      I2C_Pressure_slWrBufIndex = 0u;
                  }
              
              #endif  /* End (0u != (I2C_Pressure_MODE & I2C_Pressure_MODE_SLAVE)) */
1507          
1508          
1509          /* [] END OF FILE */
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 26  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION I2C_Pressure_Init (BEGIN)
                                           ; SOURCE LINE # 88
                                           ; SOURCE LINE # 89
                                           ; SOURCE LINE # 92
0000 9049D6            MOV     DPTR,#049D6H
0003 7406              MOV     A,#06H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 95
0006 9049C8            MOV     DPTR,#049C8H
0009 7481              MOV     A,#081H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 101
000C 9049DB            MOV     DPTR,#049DBH
000F 740F              MOV     A,#0FH
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 102
0012 9049DC            MOV     DPTR,#049DCH
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 121
0017 7F0F              MOV     R7,#0FH
0019 120000      E     LCALL   _?CyIntDisable
                                           ; SOURCE LINE # 122
001C 7C00        E     MOV     R4,#HIGH I2C_Pressure_ISR
001E 7D00        E     MOV     R5,#LOW I2C_Pressure_ISR
0020 7F0F              MOV     R7,#0FH
0022 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 123
0025 7D07              MOV     R5,#07H
0027 7F0F              MOV     R7,#0FH
0029 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 126
002C 900000      E     MOV     DPTR,#I2C_Pressure_state
002F 7410              MOV     A,#010H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 142
0032 120000      R     LCALL   I2C_Pressure_MasterClearReadBuf
                                           ; SOURCE LINE # 143
0035 120000      R     LCALL   I2C_Pressure_MasterClearWriteBuf
                                           ; SOURCE LINE # 144
0038 120000      R     LCALL   I2C_Pressure_MasterClearStatus
                                           ; SOURCE LINE # 147
003B 22                RET     
             ; FUNCTION I2C_Pressure_Init (END)

             ; FUNCTION I2C_Pressure_Enable (BEGIN)
                                           ; SOURCE LINE # 167
                                           ; SOURCE LINE # 168
                                           ; SOURCE LINE # 176
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 178
0008 9043A5            MOV     DPTR,#043A5H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4404              ORL     A,#04H
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 27  

0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 179
0013 9043B5            MOV     DPTR,#043B5H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4404              ORL     A,#04H
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 180
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 195
0026 22                RET     
             ; FUNCTION I2C_Pressure_Enable (END)

             ; FUNCTION I2C_Pressure_Start (BEGIN)
                                           ; SOURCE LINE # 225
                                           ; SOURCE LINE # 226
                                           ; SOURCE LINE # 228
0000 900000      R     MOV     DPTR,#I2C_Pressure_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0003
                                           ; SOURCE LINE # 229
                                           ; SOURCE LINE # 230
0008 120000      R     LCALL   I2C_Pressure_Init
                                           ; SOURCE LINE # 231
000B 900000      R     MOV     DPTR,#I2C_Pressure_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 232
0011         ?C0003:
                                           ; SOURCE LINE # 235
0011 120000      R     LCALL   I2C_Pressure_Enable
                                           ; SOURCE LINE # 238
0014 7F0F              MOV     R7,#0FH
0016 120000      E     LCALL   _?CyIntEnable
                                           ; SOURCE LINE # 239
0019 22                RET     
             ; FUNCTION I2C_Pressure_Start (END)

             ; FUNCTION I2C_Pressure_Stop (BEGIN)
                                           ; SOURCE LINE # 257
                                           ; SOURCE LINE # 258
                                           ; SOURCE LINE # 266
0000 7F0F              MOV     R7,#0FH
0002 120000      E     LCALL   _?CyIntDisable
                                           ; SOURCE LINE # 276
0005 9049DB            MOV     DPTR,#049DBH
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      E     MOV     DPTR,#I2C_Pressure_backup+03H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 277
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 28  

000F 9049DC            MOV     DPTR,#049DCH
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 900000      E     MOV     DPTR,#I2C_Pressure_backup+04H
0017 EF                MOV     A,R7
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 280
0019 9049D6            MOV     DPTR,#049D6H
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E EF                MOV     A,R7
001F 54FD              ANL     A,#0FDH
0021 FF                MOV     R7,A
0022 EF                MOV     A,R7
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 283
0024 7F02              MOV     R7,#02H
0026 7E00              MOV     R6,#00H
0028 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 287
002B 9049D6            MOV     DPTR,#049D6H
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
0030 EF                MOV     A,R7
0031 4402              ORL     A,#02H
0033 FF                MOV     R7,A
0034 EF                MOV     A,R7
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 294
0036 900000      E     MOV     DPTR,#I2C_Pressure_backup+03H
0039 E0                MOVX    A,@DPTR
003A FF                MOV     R7,A
003B 9049DB            MOV     DPTR,#049DBH
003E EF                MOV     A,R7
003F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 295
0040 900000      E     MOV     DPTR,#I2C_Pressure_backup+04H
0043 E0                MOVX    A,@DPTR
0044 FF                MOV     R7,A
0045 9049DC            MOV     DPTR,#049DCH
0048 EF                MOV     A,R7
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 299
004A 120000      E     LCALL   CyEnterCriticalSection
004D 900000      R     MOV     DPTR,#enableInterrupts
0050 EF                MOV     A,R7
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 301
0052 9043A5            MOV     DPTR,#043A5H
0055 E0                MOVX    A,@DPTR
0056 FF                MOV     R7,A
0057 EF                MOV     A,R7
0058 54FB              ANL     A,#0FBH
005A FF                MOV     R7,A
005B EF                MOV     A,R7
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 302
005D 9043B5            MOV     DPTR,#043B5H
0060 E0                MOVX    A,@DPTR
0061 FF                MOV     R7,A
0062 EF                MOV     A,R7
0063 54FB              ANL     A,#0FBH
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 29  

0065 FF                MOV     R7,A
0066 EF                MOV     A,R7
0067 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 303
0068 900000      R     MOV     DPTR,#enableInterrupts
006B E0                MOVX    A,@DPTR
006C FF                MOV     R7,A
006D 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 320
0070 7F0F              MOV     R7,#0FH
0072 120000      E     LCALL   _CyIntClearPending
                                           ; SOURCE LINE # 323
0075 900000      E     MOV     DPTR,#I2C_Pressure_state
0078 7410              MOV     A,#010H
007A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 326
007B 22                RET     
             ; FUNCTION I2C_Pressure_Stop (END)

             ; FUNCTION I2C_Pressure_MasterStatus (BEGIN)
                                           ; SOURCE LINE # 387
                                           ; SOURCE LINE # 388
                                           ; SOURCE LINE # 391
0000 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#status
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 394
000A 900000      E     MOV     DPTR,#I2C_Pressure_state
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 5440              ANL     A,#040H
0012 FF                MOV     R7,A
0013 7E00              MOV     R6,#00H
0015 EF                MOV     A,R7
0016 4E                ORL     A,R6
0017 600E              JZ      ?C0007
                                           ; SOURCE LINE # 395
                                           ; SOURCE LINE # 397
0019 900000      R     MOV     DPTR,#status
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E EF                MOV     A,R7
001F 4404              ORL     A,#04H
0021 FF                MOV     R7,A
0022 900000      R     MOV     DPTR,#status
0025 EF                MOV     A,R7
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 398
                                           ; SOURCE LINE # 400
                                           ; SOURCE LINE # 402
0027         ?C0007:
                                           ; SOURCE LINE # 404
0027 900000      R     MOV     DPTR,#status
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
                                           ; SOURCE LINE # 405
002C         ?C0008:
002C 22                RET     
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 30  

             ; FUNCTION I2C_Pressure_MasterStatus (END)

             ; FUNCTION I2C_Pressure_MasterClearStatus (BEGIN)
                                           ; SOURCE LINE # 428
                                           ; SOURCE LINE # 429
                                           ; SOURCE LINE # 434
0000 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#status
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 435
000A 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
000D E4                CLR     A
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 437
000F 900000      R     MOV     DPTR,#status
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
                                           ; SOURCE LINE # 438
0014         ?C0009:
0014 22                RET     
             ; FUNCTION I2C_Pressure_MasterClearStatus (END)

             ; FUNCTION _I2C_Pressure_MasterWriteBuf (BEGIN)
                                           ; SOURCE LINE # 479
0000 900000      R     MOV     DPTR,#slaveAddress
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#xferData
0008 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 481
                                           ; SOURCE LINE # 482
000B 900000      R     MOV     DPTR,#errStatus
000E 7402              MOV     A,#02H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 485
0011 7B00              MOV     R3,#00H
0013 7A00              MOV     R2,#00H
0015 7900              MOV     R1,#00H
0017 C003              PUSH    AR3
0019 C002              PUSH    AR2
001B C001              PUSH    AR1
001D 900000      R     MOV     DPTR,#xferData
0020 120000      E     LCALL   ?C?PLDXDATA
0023 D082              POP     DPL
0025 D083              POP     DPH
0027 D0E0              POP     ACC
0029 6B                XRL     A,R3
002A 7008              JNZ     ?C0076
002C E9                MOV     A,R1
002D 6582              XRL     A,DPL
002F 7003              JNZ     ?C0076
0031 EA                MOV     A,R2
0032 6583              XRL     A,DPH
0034         ?C0076:
0034 7003              JNZ     $ + 5H
0036 020000      R     LJMP    ?C0010
                                           ; SOURCE LINE # 486
                                           ; SOURCE LINE # 488
0039 900000      E     MOV     DPTR,#I2C_Pressure_state
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 31  

003C E0                MOVX    A,@DPTR
003D FF                MOV     R7,A
003E EF                MOV     A,R7
003F 6410              XRL     A,#010H
0041 600D              JZ      ?C0012
0043 900000      E     MOV     DPTR,#I2C_Pressure_state
0046 E0                MOVX    A,@DPTR
0047 FF                MOV     R7,A
0048 EF                MOV     A,R7
0049 6460              XRL     A,#060H
004B 6003              JZ      $ + 5H
004D 020000      R     LJMP    ?C0010
0050         ?C0012:
                                           ; SOURCE LINE # 490
                                           ; SOURCE LINE # 492
0050 900000      E     MOV     DPTR,#I2C_Pressure_state
0053 E0                MOVX    A,@DPTR
0054 FF                MOV     R7,A
0055 EF                MOV     A,R7
0056 B4101E            CJNE    A,#010H,?C0013
                                           ; SOURCE LINE # 493
                                           ; SOURCE LINE # 495
0059 9049D9            MOV     DPTR,#049D9H
005C E0                MOVX    A,@DPTR
005D FF                MOV     R7,A
005E EF                MOV     A,R7
005F 5408              ANL     A,#08H
0061 FF                MOV     R7,A
0062 7E00              MOV     R6,#00H
0064 EF                MOV     A,R7
0065 4E                ORL     A,R6
0066 7007              JNZ     ?C0014
                                           ; SOURCE LINE # 496
                                           ; SOURCE LINE # 497
0068 900000      R     MOV     DPTR,#errStatus
006B E4                CLR     A
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 498
006D 8020              SJMP    ?C0016
006F         ?C0014:
                                           ; SOURCE LINE # 500
                                           ; SOURCE LINE # 501
006F 900000      R     MOV     DPTR,#errStatus
0072 7401              MOV     A,#01H
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 502
                                           ; SOURCE LINE # 503
0075 8018              SJMP    ?C0016
0077         ?C0013:
                                           ; SOURCE LINE # 505
                                           ; SOURCE LINE # 506
0077 7F0F              MOV     R7,#0FH
0079 120000      E     LCALL   _CyIntClearPending
                                           ; SOURCE LINE # 507
007C 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
007F E0                MOVX    A,@DPTR
0080 FF                MOV     R7,A
0081 EF                MOV     A,R7
0082 54F7              ANL     A,#0F7H
0084 FF                MOV     R7,A
0085 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
0088 EF                MOV     A,R7
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 32  

0089 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 508
008A 900000      R     MOV     DPTR,#errStatus
008D E4                CLR     A
008E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 509
008F         ?C0016:
                                           ; SOURCE LINE # 512
008F 900000      R     MOV     DPTR,#errStatus
0092 E0                MOVX    A,@DPTR
0093 FF                MOV     R7,A
0094 EF                MOV     A,R7
0095 6003              JZ      $ + 5H
0097 020000      R     LJMP    ?C0010
                                           ; SOURCE LINE # 513
                                           ; SOURCE LINE # 515
009A 900000      R     MOV     DPTR,#mode
009D E0                MOVX    A,@DPTR
009E FF                MOV     R7,A
009F EF                MOV     A,R7
00A0 5402              ANL     A,#02H
00A2 FF                MOV     R7,A
00A3 7E00              MOV     R6,#00H
00A5 EF                MOV     A,R7
00A6 4E                ORL     A,R6
00A7 6010              JZ      ?C0018
                                           ; SOURCE LINE # 516
                                           ; SOURCE LINE # 517
00A9 900000      E     MOV     DPTR,#I2C_Pressure_mstrControl
00AC E0                MOVX    A,@DPTR
00AD FF                MOV     R7,A
00AE EF                MOV     A,R7
00AF 4401              ORL     A,#01H
00B1 FF                MOV     R7,A
00B2 900000      E     MOV     DPTR,#I2C_Pressure_mstrControl
00B5 EF                MOV     A,R7
00B6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 518
00B7 800E              SJMP    ?C0019
00B9         ?C0018:
                                           ; SOURCE LINE # 520
                                           ; SOURCE LINE # 521
00B9 900000      E     MOV     DPTR,#I2C_Pressure_mstrControl
00BC E0                MOVX    A,@DPTR
00BD FF                MOV     R7,A
00BE EF                MOV     A,R7
00BF 54FE              ANL     A,#0FEH
00C1 FF                MOV     R7,A
00C2 900000      E     MOV     DPTR,#I2C_Pressure_mstrControl
00C5 EF                MOV     A,R7
00C6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 522
00C7         ?C0019:
                                           ; SOURCE LINE # 524
00C7 900000      E     MOV     DPTR,#I2C_Pressure_state
00CA 7445              MOV     A,#045H
00CC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 525
00CD 900000      R     MOV     DPTR,#slaveAddress
00D0 E0                MOVX    A,@DPTR
00D1 FF                MOV     R7,A
00D2 EF                MOV     A,R7
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 33  

00D3 25E0              ADD     A,ACC
00D5 FF                MOV     R7,A
00D6 900000      R     MOV     DPTR,#slaveAddress
00D9 EF                MOV     A,R7
00DA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 526
00DB 900000      R     MOV     DPTR,#slaveAddress
00DE E0                MOVX    A,@DPTR
00DF FF                MOV     R7,A
00E0 9049D8            MOV     DPTR,#049D8H
00E3 EF                MOV     A,R7
00E4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 528
00E5 900000      E     MOV     DPTR,#I2C_Pressure_mstrWrBufIndex
00E8 E4                CLR     A
00E9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 529
00EA 900000      R     MOV     DPTR,#cnt
00ED E0                MOVX    A,@DPTR
00EE FF                MOV     R7,A
00EF 900000      E     MOV     DPTR,#I2C_Pressure_mstrWrBufSize
00F2 EF                MOV     A,R7
00F3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 530
00F4 900000      R     MOV     DPTR,#xferData
00F7 120000      E     LCALL   ?C?PLDXDATA
00FA 900000      E     MOV     DPTR,#I2C_Pressure_mstrWrBufPtr
00FD 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 533
0100 900000      R     MOV     DPTR,#mode
0103 E0                MOVX    A,@DPTR
0104 FF                MOV     R7,A
0105 EF                MOV     A,R7
0106 5401              ANL     A,#01H
0108 FF                MOV     R7,A
0109 7E00              MOV     R6,#00H
010B EF                MOV     A,R7
010C 4E                ORL     A,R6
010D 600E              JZ      ?C0020
                                           ; SOURCE LINE # 534
                                           ; SOURCE LINE # 535
010F 9049D9            MOV     DPTR,#049D9H
0112 7412              MOV     A,#012H
0114 F0                MOVX    @DPTR,A
0115 9049D7            MOV     DPTR,#049D7H
0118 7404              MOV     A,#04H
011A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 536
011B 8006              SJMP    ?C0021
011D         ?C0020:
                                           ; SOURCE LINE # 538
                                           ; SOURCE LINE # 539
011D 9049D9            MOV     DPTR,#049D9H
0120 7401              MOV     A,#01H
0122 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 540
0123         ?C0021:
                                           ; SOURCE LINE # 543
0123 7F0F              MOV     R7,#0FH
0125 120000      E     LCALL   _?CyIntEnable
                                           ; SOURCE LINE # 546
0128 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 34  

012B E0                MOVX    A,@DPTR
012C FF                MOV     R7,A
012D EF                MOV     A,R7
012E 54FD              ANL     A,#0FDH
0130 FF                MOV     R7,A
0131 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
0134 EF                MOV     A,R7
0135 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 547
                                           ; SOURCE LINE # 548
                                           ; SOURCE LINE # 549
0136         ?C0010:
                                           ; SOURCE LINE # 551
0136 900000      R     MOV     DPTR,#errStatus
0139 E0                MOVX    A,@DPTR
013A FF                MOV     R7,A
                                           ; SOURCE LINE # 552
013B         ?C0022:
013B 22                RET     
             ; FUNCTION _I2C_Pressure_MasterWriteBuf (END)

             ; FUNCTION _I2C_Pressure_MasterReadBuf (BEGIN)
                                           ; SOURCE LINE # 593
0000 900000      R     MOV     DPTR,#slaveAddress
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#xferData
0008 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 595
                                           ; SOURCE LINE # 596
000B 900000      R     MOV     DPTR,#errStatus
000E 7402              MOV     A,#02H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 599
0011 7B00              MOV     R3,#00H
0013 7A00              MOV     R2,#00H
0015 7900              MOV     R1,#00H
0017 C003              PUSH    AR3
0019 C002              PUSH    AR2
001B C001              PUSH    AR1
001D 900000      R     MOV     DPTR,#xferData
0020 120000      E     LCALL   ?C?PLDXDATA
0023 D082              POP     DPL
0025 D083              POP     DPH
0027 D0E0              POP     ACC
0029 6B                XRL     A,R3
002A 7008              JNZ     ?C0077
002C E9                MOV     A,R1
002D 6582              XRL     A,DPL
002F 7003              JNZ     ?C0077
0031 EA                MOV     A,R2
0032 6583              XRL     A,DPH
0034         ?C0077:
0034 7003              JNZ     $ + 5H
0036 020000      R     LJMP    ?C0023
                                           ; SOURCE LINE # 600
                                           ; SOURCE LINE # 602
0039 900000      E     MOV     DPTR,#I2C_Pressure_state
003C E0                MOVX    A,@DPTR
003D FF                MOV     R7,A
003E EF                MOV     A,R7
003F 6410              XRL     A,#010H
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 35  

0041 600D              JZ      ?C0025
0043 900000      E     MOV     DPTR,#I2C_Pressure_state
0046 E0                MOVX    A,@DPTR
0047 FF                MOV     R7,A
0048 EF                MOV     A,R7
0049 6460              XRL     A,#060H
004B 6003              JZ      $ + 5H
004D 020000      R     LJMP    ?C0023
0050         ?C0025:
                                           ; SOURCE LINE # 604
                                           ; SOURCE LINE # 606
0050 900000      E     MOV     DPTR,#I2C_Pressure_state
0053 E0                MOVX    A,@DPTR
0054 FF                MOV     R7,A
0055 EF                MOV     A,R7
0056 B4101E            CJNE    A,#010H,?C0026
                                           ; SOURCE LINE # 607
                                           ; SOURCE LINE # 609
0059 9049D9            MOV     DPTR,#049D9H
005C E0                MOVX    A,@DPTR
005D FF                MOV     R7,A
005E EF                MOV     A,R7
005F 5408              ANL     A,#08H
0061 FF                MOV     R7,A
0062 7E00              MOV     R6,#00H
0064 EF                MOV     A,R7
0065 4E                ORL     A,R6
0066 7007              JNZ     ?C0027
                                           ; SOURCE LINE # 610
                                           ; SOURCE LINE # 611
0068 900000      R     MOV     DPTR,#errStatus
006B E4                CLR     A
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 612
006D 8020              SJMP    ?C0029
006F         ?C0027:
                                           ; SOURCE LINE # 614
                                           ; SOURCE LINE # 615
006F 900000      R     MOV     DPTR,#errStatus
0072 7401              MOV     A,#01H
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 616
                                           ; SOURCE LINE # 617
0075 8018              SJMP    ?C0029
0077         ?C0026:
                                           ; SOURCE LINE # 619
                                           ; SOURCE LINE # 620
0077 7F0F              MOV     R7,#0FH
0079 120000      E     LCALL   _CyIntClearPending
                                           ; SOURCE LINE # 621
007C 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
007F E0                MOVX    A,@DPTR
0080 FF                MOV     R7,A
0081 EF                MOV     A,R7
0082 54F7              ANL     A,#0F7H
0084 FF                MOV     R7,A
0085 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
0088 EF                MOV     A,R7
0089 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 622
008A 900000      R     MOV     DPTR,#errStatus
008D E4                CLR     A
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 36  

008E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 623
008F         ?C0029:
                                           ; SOURCE LINE # 626
008F 900000      R     MOV     DPTR,#errStatus
0092 E0                MOVX    A,@DPTR
0093 FF                MOV     R7,A
0094 EF                MOV     A,R7
0095 6003              JZ      $ + 5H
0097 020000      R     LJMP    ?C0023
                                           ; SOURCE LINE # 627
                                           ; SOURCE LINE # 629
009A 900000      R     MOV     DPTR,#mode
009D E0                MOVX    A,@DPTR
009E FF                MOV     R7,A
009F EF                MOV     A,R7
00A0 5402              ANL     A,#02H
00A2 FF                MOV     R7,A
00A3 7E00              MOV     R6,#00H
00A5 EF                MOV     A,R7
00A6 4E                ORL     A,R6
00A7 6010              JZ      ?C0031
                                           ; SOURCE LINE # 630
                                           ; SOURCE LINE # 631
00A9 900000      E     MOV     DPTR,#I2C_Pressure_mstrControl
00AC E0                MOVX    A,@DPTR
00AD FF                MOV     R7,A
00AE EF                MOV     A,R7
00AF 4401              ORL     A,#01H
00B1 FF                MOV     R7,A
00B2 900000      E     MOV     DPTR,#I2C_Pressure_mstrControl
00B5 EF                MOV     A,R7
00B6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 632
00B7 800E              SJMP    ?C0032
00B9         ?C0031:
                                           ; SOURCE LINE # 634
                                           ; SOURCE LINE # 635
00B9 900000      E     MOV     DPTR,#I2C_Pressure_mstrControl
00BC E0                MOVX    A,@DPTR
00BD FF                MOV     R7,A
00BE EF                MOV     A,R7
00BF 54FE              ANL     A,#0FEH
00C1 FF                MOV     R7,A
00C2 900000      E     MOV     DPTR,#I2C_Pressure_mstrControl
00C5 EF                MOV     A,R7
00C6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 636
00C7         ?C0032:
                                           ; SOURCE LINE # 638
00C7 900000      E     MOV     DPTR,#I2C_Pressure_state
00CA 7449              MOV     A,#049H
00CC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 639
00CD 900000      R     MOV     DPTR,#slaveAddress
00D0 E0                MOVX    A,@DPTR
00D1 FF                MOV     R7,A
00D2 EF                MOV     A,R7
00D3 25E0              ADD     A,ACC
00D5 FF                MOV     R7,A
00D6 900000      R     MOV     DPTR,#slaveAddress
00D9 EF                MOV     A,R7
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 37  

00DA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 640
00DB 900000      R     MOV     DPTR,#slaveAddress
00DE E0                MOVX    A,@DPTR
00DF FF                MOV     R7,A
00E0 EF                MOV     A,R7
00E1 4401              ORL     A,#01H
00E3 FF                MOV     R7,A
00E4 900000      R     MOV     DPTR,#slaveAddress
00E7 EF                MOV     A,R7
00E8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 641
00E9 900000      R     MOV     DPTR,#slaveAddress
00EC E0                MOVX    A,@DPTR
00ED FF                MOV     R7,A
00EE 9049D8            MOV     DPTR,#049D8H
00F1 EF                MOV     A,R7
00F2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 643
00F3 900000      E     MOV     DPTR,#I2C_Pressure_mstrRdBufIndex
00F6 E4                CLR     A
00F7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 644
00F8 900000      R     MOV     DPTR,#cnt
00FB E0                MOVX    A,@DPTR
00FC FF                MOV     R7,A
00FD 900000      E     MOV     DPTR,#I2C_Pressure_mstrRdBufSize
0100 EF                MOV     A,R7
0101 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 645
0102 900000      R     MOV     DPTR,#xferData
0105 120000      E     LCALL   ?C?PLDXDATA
0108 900000      E     MOV     DPTR,#I2C_Pressure_mstrRdBufPtr
010B 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 648
010E 900000      R     MOV     DPTR,#mode
0111 E0                MOVX    A,@DPTR
0112 FF                MOV     R7,A
0113 EF                MOV     A,R7
0114 5401              ANL     A,#01H
0116 FF                MOV     R7,A
0117 7E00              MOV     R6,#00H
0119 EF                MOV     A,R7
011A 4E                ORL     A,R6
011B 600E              JZ      ?C0033
                                           ; SOURCE LINE # 649
                                           ; SOURCE LINE # 650
011D 9049D9            MOV     DPTR,#049D9H
0120 7412              MOV     A,#012H
0122 F0                MOVX    @DPTR,A
0123 9049D7            MOV     DPTR,#049D7H
0126 7404              MOV     A,#04H
0128 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 651
0129 8006              SJMP    ?C0034
012B         ?C0033:
                                           ; SOURCE LINE # 653
                                           ; SOURCE LINE # 654
012B 9049D9            MOV     DPTR,#049D9H
012E 7401              MOV     A,#01H
0130 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 655
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 38  

0131         ?C0034:
                                           ; SOURCE LINE # 658
0131 7F0F              MOV     R7,#0FH
0133 120000      E     LCALL   _?CyIntEnable
                                           ; SOURCE LINE # 661
0136 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
0139 E0                MOVX    A,@DPTR
013A FF                MOV     R7,A
013B EF                MOV     A,R7
013C 54FE              ANL     A,#0FEH
013E FF                MOV     R7,A
013F 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
0142 EF                MOV     A,R7
0143 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 662
                                           ; SOURCE LINE # 663
                                           ; SOURCE LINE # 664
0144         ?C0023:
                                           ; SOURCE LINE # 666
0144 900000      R     MOV     DPTR,#errStatus
0147 E0                MOVX    A,@DPTR
0148 FF                MOV     R7,A
                                           ; SOURCE LINE # 667
0149         ?C0035:
0149 22                RET     
             ; FUNCTION _I2C_Pressure_MasterReadBuf (END)

             ; FUNCTION _I2C_Pressure_MasterSendStart (BEGIN)
                                           ; SOURCE LINE # 695
0000 900000      R     MOV     DPTR,#slaveAddress
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#R_nW
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 697
                                           ; SOURCE LINE # 698
000A 900000      R     MOV     DPTR,#errStatus
000D 7402              MOV     A,#02H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 701
0010 900000      E     MOV     DPTR,#I2C_Pressure_state
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 6410              XRL     A,#010H
0018 6003              JZ      $ + 5H
001A 020000      R     LJMP    ?C0036
                                           ; SOURCE LINE # 702
                                           ; SOURCE LINE # 704
001D 9049D9            MOV     DPTR,#049D9H
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
0022 EF                MOV     A,R7
0023 5408              ANL     A,#08H
0025 FF                MOV     R7,A
0026 7E00              MOV     R6,#00H
0028 EF                MOV     A,R7
0029 4E                ORL     A,R6
002A 707C              JNZ     ?C0037
                                           ; SOURCE LINE # 705
                                           ; SOURCE LINE # 707
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 39  

002C 7F0F              MOV     R7,#0FH
002E 120000      E     LCALL   _?CyIntDisable
                                           ; SOURCE LINE # 709
0031 900000      R     MOV     DPTR,#slaveAddress
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
0036 EF                MOV     A,R7
0037 25E0              ADD     A,ACC
0039 FF                MOV     R7,A
003A 900000      R     MOV     DPTR,#slaveAddress
003D EF                MOV     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 710
003F 900000      R     MOV     DPTR,#R_nW
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 EF                MOV     A,R7
0045 6016              JZ      ?C0038
                                           ; SOURCE LINE # 711
                                           ; SOURCE LINE # 712
0047 900000      R     MOV     DPTR,#slaveAddress
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C EF                MOV     A,R7
004D 4401              ORL     A,#01H
004F FF                MOV     R7,A
0050 900000      R     MOV     DPTR,#slaveAddress
0053 EF                MOV     A,R7
0054 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 713
0055 900000      E     MOV     DPTR,#I2C_Pressure_state
0058 7449              MOV     A,#049H
005A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 714
005B 8006              SJMP    ?C0039
005D         ?C0038:
                                           ; SOURCE LINE # 716
                                           ; SOURCE LINE # 717
005D 900000      E     MOV     DPTR,#I2C_Pressure_state
0060 7445              MOV     A,#045H
0062 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 718
0063         ?C0039:
                                           ; SOURCE LINE # 719
0063 900000      R     MOV     DPTR,#slaveAddress
0066 E0                MOVX    A,@DPTR
0067 FF                MOV     R7,A
0068 9049D8            MOV     DPTR,#049D8H
006B EF                MOV     A,R7
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 722
006D 9049D9            MOV     DPTR,#049D9H
0070 7401              MOV     A,#01H
0072 F0                MOVX    @DPTR,A
0073         ?C0040:
                                           ; SOURCE LINE # 725
0073 9049D7            MOV     DPTR,#049D7H
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078 EF                MOV     A,R7
0079 5401              ANL     A,#01H
007B FF                MOV     R7,A
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 40  

007C 7E00              MOV     R6,#00H
007E EF                MOV     A,R7
007F 4E                ORL     A,R6
0080 60F1              JZ      ?C0040
0082         ?C0041:
                                           ; SOURCE LINE # 751
0082 9049D7            MOV     DPTR,#049D7H
0085 E0                MOVX    A,@DPTR
0086 FF                MOV     R7,A
0087 EF                MOV     A,R7
0088 540A              ANL     A,#0AH
008A FF                MOV     R7,A
008B 7E00              MOV     R6,#00H
008D EF                MOV     A,R7
008E 640A              XRL     A,#0AH
0090 4E                ORL     A,R6
0091 700E              JNZ     ?C0042
                                           ; SOURCE LINE # 752
                                           ; SOURCE LINE # 754
0093 900000      E     MOV     DPTR,#I2C_Pressure_state
0096 7410              MOV     A,#010H
0098 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 755
0099 900000      R     MOV     DPTR,#errStatus
009C 7403              MOV     A,#03H
009E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 756
009F 800D              SJMP    ?C0036
00A1         ?C0042:
                                           ; SOURCE LINE # 758
                                           ; SOURCE LINE # 759
00A1 900000      R     MOV     DPTR,#errStatus
00A4 E4                CLR     A
00A5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 760
                                           ; SOURCE LINE # 761
00A6 8006              SJMP    ?C0036
00A8         ?C0037:
                                           ; SOURCE LINE # 763
                                           ; SOURCE LINE # 764
00A8 900000      R     MOV     DPTR,#errStatus
00AB 7401              MOV     A,#01H
00AD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 765
                                           ; SOURCE LINE # 766
00AE         ?C0036:
                                           ; SOURCE LINE # 768
00AE 900000      R     MOV     DPTR,#errStatus
00B1 E0                MOVX    A,@DPTR
00B2 FF                MOV     R7,A
                                           ; SOURCE LINE # 769
00B3         ?C0045:
00B3 22                RET     
             ; FUNCTION _I2C_Pressure_MasterSendStart (END)

             ; FUNCTION _I2C_Pressure_MasterSendRestart (BEGIN)
                                           ; SOURCE LINE # 797
0000 900000      R     MOV     DPTR,#slaveAddress
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#R_nW
0008 ED                MOV     A,R5
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 41  

0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 799
                                           ; SOURCE LINE # 800
000A 900000      R     MOV     DPTR,#errStatus
000D 7402              MOV     A,#02H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 803
0010 9049D9            MOV     DPTR,#049D9H
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 5404              ANL     A,#04H
0018 FF                MOV     R7,A
0019 7E00              MOV     R6,#00H
001B EF                MOV     A,R7
001C 4E                ORL     A,R6
001D 607B              JZ      ?C0046
                                           ; SOURCE LINE # 804
                                           ; SOURCE LINE # 805
001F 900000      R     MOV     DPTR,#slaveAddress
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 EF                MOV     A,R7
0025 25E0              ADD     A,ACC
0027 FF                MOV     R7,A
0028 900000      R     MOV     DPTR,#slaveAddress
002B EF                MOV     A,R7
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 806
002D 900000      R     MOV     DPTR,#R_nW
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 6016              JZ      ?C0047
                                           ; SOURCE LINE # 807
                                           ; SOURCE LINE # 808
0035 900000      R     MOV     DPTR,#slaveAddress
0038 E0                MOVX    A,@DPTR
0039 FF                MOV     R7,A
003A EF                MOV     A,R7
003B 4401              ORL     A,#01H
003D FF                MOV     R7,A
003E 900000      R     MOV     DPTR,#slaveAddress
0041 EF                MOV     A,R7
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 809
0043 900000      E     MOV     DPTR,#I2C_Pressure_state
0046 7449              MOV     A,#049H
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 810
0049 8006              SJMP    ?C0048
004B         ?C0047:
                                           ; SOURCE LINE # 812
                                           ; SOURCE LINE # 813
004B 900000      E     MOV     DPTR,#I2C_Pressure_state
004E 7445              MOV     A,#045H
0050 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 814
0051         ?C0048:
                                           ; SOURCE LINE # 815
0051 900000      R     MOV     DPTR,#slaveAddress
0054 E0                MOVX    A,@DPTR
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 42  

0055 FF                MOV     R7,A
0056 9049D8            MOV     DPTR,#049D8H
0059 EF                MOV     A,R7
005A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 818
005B 9049D9            MOV     DPTR,#049D9H
005E 7412              MOV     A,#012H
0060 F0                MOVX    @DPTR,A
0061 9049D7            MOV     DPTR,#049D7H
0064 7404              MOV     A,#04H
0066 F0                MOVX    @DPTR,A
0067         ?C0049:
                                           ; SOURCE LINE # 824
0067 9049D7            MOV     DPTR,#049D7H
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C EF                MOV     A,R7
006D 5401              ANL     A,#01H
006F FF                MOV     R7,A
0070 7E00              MOV     R6,#00H
0072 EF                MOV     A,R7
0073 4E                ORL     A,R6
0074 60F1              JZ      ?C0049
0076         ?C0050:
                                           ; SOURCE LINE # 838
0076 9049D7            MOV     DPTR,#049D7H
0079 E0                MOVX    A,@DPTR
007A FF                MOV     R7,A
007B EF                MOV     A,R7
007C 540A              ANL     A,#0AH
007E FF                MOV     R7,A
007F 7E00              MOV     R6,#00H
0081 EF                MOV     A,R7
0082 640A              XRL     A,#0AH
0084 4E                ORL     A,R6
0085 700E              JNZ     ?C0051
                                           ; SOURCE LINE # 839
                                           ; SOURCE LINE # 841
0087 900000      E     MOV     DPTR,#I2C_Pressure_state
008A 7410              MOV     A,#010H
008C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 842
008D 900000      R     MOV     DPTR,#errStatus
0090 7403              MOV     A,#03H
0092 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 843
0093 8005              SJMP    ?C0046
0095         ?C0051:
                                           ; SOURCE LINE # 845
                                           ; SOURCE LINE # 846
0095 900000      R     MOV     DPTR,#errStatus
0098 E4                CLR     A
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 847
                                           ; SOURCE LINE # 848
009A         ?C0046:
                                           ; SOURCE LINE # 850
009A 900000      R     MOV     DPTR,#errStatus
009D E0                MOVX    A,@DPTR
009E FF                MOV     R7,A
                                           ; SOURCE LINE # 851
009F         ?C0053:
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 43  

009F 22                RET     
             ; FUNCTION _I2C_Pressure_MasterSendRestart (END)

             ; FUNCTION I2C_Pressure_MasterSendStop (BEGIN)
                                           ; SOURCE LINE # 879
                                           ; SOURCE LINE # 880
                                           ; SOURCE LINE # 881
0000 900000      R     MOV     DPTR,#errStatus
0003 7402              MOV     A,#02H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 884
0006 9049D9            MOV     DPTR,#049D9H
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B EF                MOV     A,R7
000C 5404              ANL     A,#04H
000E FF                MOV     R7,A
000F 7E00              MOV     R6,#00H
0011 EF                MOV     A,R7
0012 4E                ORL     A,R6
0013 6026              JZ      ?C0054
                                           ; SOURCE LINE # 885
                                           ; SOURCE LINE # 886
0015 9049D9            MOV     DPTR,#049D9H
0018 7410              MOV     A,#010H
001A F0                MOVX    @DPTR,A
001B 9049D7            MOV     DPTR,#049D7H
001E 7404              MOV     A,#04H
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 887
0021 900000      E     MOV     DPTR,#I2C_Pressure_state
0024 7410              MOV     A,#010H
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 888
0027 900000      R     MOV     DPTR,#errStatus
002A E4                CLR     A
002B F0                MOVX    @DPTR,A
002C         ?C0055:
                                           ; SOURCE LINE # 912
002C 9049D7            MOV     DPTR,#049D7H
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 EF                MOV     A,R7
0032 5420              ANL     A,#020H
0034 FF                MOV     R7,A
0035 7E00              MOV     R6,#00H
0037 EF                MOV     A,R7
0038 4E                ORL     A,R6
0039 60F1              JZ      ?C0055
003B         ?C0056:
                                           ; SOURCE LINE # 914
003B         ?C0054:
                                           ; SOURCE LINE # 916
003B 900000      R     MOV     DPTR,#errStatus
003E E0                MOVX    A,@DPTR
003F FF                MOV     R7,A
                                           ; SOURCE LINE # 917
0040         ?C0057:
0040 22                RET     
             ; FUNCTION I2C_Pressure_MasterSendStop (END)

             ; FUNCTION _I2C_Pressure_MasterWriteByte (BEGIN)
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 44  

                                           ; SOURCE LINE # 943
0000 900000      R     MOV     DPTR,#theByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 944
                                           ; SOURCE LINE # 945
0005 900000      R     MOV     DPTR,#errStatus
0008 7402              MOV     A,#02H
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 948
000B 9049D9            MOV     DPTR,#049D9H
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 5404              ANL     A,#04H
0013 FF                MOV     R7,A
0014 7E00              MOV     R6,#00H
0016 EF                MOV     A,R7
0017 4E                ORL     A,R6
0018 604D              JZ      ?C0058
                                           ; SOURCE LINE # 949
                                           ; SOURCE LINE # 950
001A 900000      R     MOV     DPTR,#theByte
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F 9049D8            MOV     DPTR,#049D8H
0022 EF                MOV     A,R7
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 951
0024 9049D7            MOV     DPTR,#049D7H
0027 7404              MOV     A,#04H
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 952
002A 900000      E     MOV     DPTR,#I2C_Pressure_state
002D 7446              MOV     A,#046H
002F F0                MOVX    @DPTR,A
0030         ?C0059:
                                           ; SOURCE LINE # 958
0030 9049D7            MOV     DPTR,#049D7H
0033 E0                MOVX    A,@DPTR
0034 FF                MOV     R7,A
0035 EF                MOV     A,R7
0036 5401              ANL     A,#01H
0038 FF                MOV     R7,A
0039 7E00              MOV     R6,#00H
003B EF                MOV     A,R7
003C 4E                ORL     A,R6
003D 60F1              JZ      ?C0059
003F         ?C0060:
                                           ; SOURCE LINE # 972
003F 9049D7            MOV     DPTR,#049D7H
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 EF                MOV     A,R7
0045 5402              ANL     A,#02H
0047 FF                MOV     R7,A
0048 7E00              MOV     R6,#00H
004A EF                MOV     A,R7
004B 4E                ORL     A,R6
004C 700D              JNZ     ?C0061
                                           ; SOURCE LINE # 973
                                           ; SOURCE LINE # 974
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 45  

004E 900000      E     MOV     DPTR,#I2C_Pressure_state
0051 7460              MOV     A,#060H
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 975
0054 900000      R     MOV     DPTR,#errStatus
0057 E4                CLR     A
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 976
0059 800C              SJMP    ?C0058
005B         ?C0061:
                                           ; SOURCE LINE # 978
                                           ; SOURCE LINE # 979
005B 900000      E     MOV     DPTR,#I2C_Pressure_state
005E 7460              MOV     A,#060H
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 980
0061 900000      R     MOV     DPTR,#errStatus
0064 7403              MOV     A,#03H
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 981
                                           ; SOURCE LINE # 982
0067         ?C0058:
                                           ; SOURCE LINE # 984
0067 900000      R     MOV     DPTR,#errStatus
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
                                           ; SOURCE LINE # 985
006C         ?C0063:
006C 22                RET     
             ; FUNCTION _I2C_Pressure_MasterWriteByte (END)

             ; FUNCTION _I2C_Pressure_MasterReadByte (BEGIN)
                                           ; SOURCE LINE # 1015
0000 900000      R     MOV     DPTR,#acknNak
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1016
                                           ; SOURCE LINE # 1017
0005 900000      R     MOV     DPTR,#theByte
0008 E4                CLR     A
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1020
000A 9049D9            MOV     DPTR,#049D9H
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 5404              ANL     A,#04H
0012 FF                MOV     R7,A
0013 7E00              MOV     R6,#00H
0015 EF                MOV     A,R7
0016 4E                ORL     A,R6
0017 6043              JZ      ?C0064
                                           ; SOURCE LINE # 1021
                                           ; SOURCE LINE # 1023
0019 900000      E     MOV     DPTR,#I2C_Pressure_state
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E EF                MOV     A,R7
001F B4490B            CJNE    A,#049H,?C0066
                                           ; SOURCE LINE # 1024
                                           ; SOURCE LINE # 1025
0022 9049D7            MOV     DPTR,#049D7H
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 46  

0025 E4                CLR     A
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1026
0027 900000      E     MOV     DPTR,#I2C_Pressure_state
002A 744A              MOV     A,#04AH
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1030
002D         ?C0066:
                                           ; SOURCE LINE # 1032
002D 9049D7            MOV     DPTR,#049D7H
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 5401              ANL     A,#01H
0035 FF                MOV     R7,A
0036 7E00              MOV     R6,#00H
0038 EF                MOV     A,R7
0039 4E                ORL     A,R6
003A 60F1              JZ      ?C0066
003C         ?C0067:
                                           ; SOURCE LINE # 1034
003C 9049D8            MOV     DPTR,#049D8H
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 900000      R     MOV     DPTR,#theByte
0044 EF                MOV     A,R7
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1039
0046 900000      R     MOV     DPTR,#acknNak
0049 E0                MOVX    A,@DPTR
004A FF                MOV     R7,A
004B EF                MOV     A,R7
004C 6008              JZ      ?C0068
                                           ; SOURCE LINE # 1040
                                           ; SOURCE LINE # 1041
004E 9049D7            MOV     DPTR,#049D7H
0051 7410              MOV     A,#010H
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1045
0054 8006              SJMP    ?C0064
0056         ?C0068:
                                           ; SOURCE LINE # 1047
                                           ; SOURCE LINE # 1049
0056 900000      E     MOV     DPTR,#I2C_Pressure_state
0059 7460              MOV     A,#060H
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1050
                                           ; SOURCE LINE # 1051
005C         ?C0064:
                                           ; SOURCE LINE # 1053
005C 900000      R     MOV     DPTR,#theByte
005F E0                MOVX    A,@DPTR
0060 FF                MOV     R7,A
                                           ; SOURCE LINE # 1054
0061         ?C0070:
0061 22                RET     
             ; FUNCTION _I2C_Pressure_MasterReadByte (END)

             ; FUNCTION I2C_Pressure_MasterGetReadBufSize (BEGIN)
                                           ; SOURCE LINE # 1077
                                           ; SOURCE LINE # 1078
                                           ; SOURCE LINE # 1079
C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 47  

0000 900000      E     MOV     DPTR,#I2C_Pressure_mstrRdBufIndex
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 1080
0005         ?C0071:
0005 22                RET     
             ; FUNCTION I2C_Pressure_MasterGetReadBufSize (END)

             ; FUNCTION I2C_Pressure_MasterGetWriteBufSize (BEGIN)
                                           ; SOURCE LINE # 1103
                                           ; SOURCE LINE # 1104
                                           ; SOURCE LINE # 1105
0000 900000      E     MOV     DPTR,#I2C_Pressure_mstrWrBufIndex
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 1106
0005         ?C0072:
0005 22                RET     
             ; FUNCTION I2C_Pressure_MasterGetWriteBufSize (END)

             ; FUNCTION I2C_Pressure_MasterClearReadBuf (BEGIN)
                                           ; SOURCE LINE # 1131
                                           ; SOURCE LINE # 1132
                                           ; SOURCE LINE # 1133
0000 900000      E     MOV     DPTR,#I2C_Pressure_mstrRdBufIndex
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1134
0005 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 54FE              ANL     A,#0FEH
000D FF                MOV     R7,A
000E 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1135
0013 22                RET     
             ; FUNCTION I2C_Pressure_MasterClearReadBuf (END)

             ; FUNCTION I2C_Pressure_MasterClearWriteBuf (BEGIN)
                                           ; SOURCE LINE # 1160
                                           ; SOURCE LINE # 1161
                                           ; SOURCE LINE # 1162
0000 900000      E     MOV     DPTR,#I2C_Pressure_mstrWrBufIndex
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1163
0005 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 54FD              ANL     A,#0FDH
000D FF                MOV     R7,A
000E 900000      E     MOV     DPTR,#I2C_Pressure_mstrStatus
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1164
0013 22                RET     
             ; FUNCTION I2C_Pressure_MasterClearWriteBuf (END)

C51 COMPILER V9.03   I2C_PRESSURE                                                          05/06/2015 05:27:51 PAGE 48  

             ; FUNCTION I2C_Pressure_Workaround (BEGIN)
                                           ; SOURCE LINE # 1184
                                           ; SOURCE LINE # 1185
                                           ; SOURCE LINE # 1187
0000 22                RET     
             ; FUNCTION I2C_Pressure_Workaround (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1626    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      29
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
